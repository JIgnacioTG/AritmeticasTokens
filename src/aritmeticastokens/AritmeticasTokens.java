package aritmeticastokens;

// librerias
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.StringTokenizer;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.swing.JOptionPane;
import javax.swing.table.DefaultTableModel;

public class AritmeticasTokens extends javax.swing.JFrame {
    
    // declaracion de variables
    Token tokens = new Token();
    ArrayList<String> tipo = new ArrayList<>();
    ArrayList<String> tipotoken = new ArrayList<>();
    ArrayList<String> errores = new ArrayList<>();
    DefaultTableModel dtmPalabras = new DefaultTableModel();
    DefaultTableModel dtmSimbolos = new DefaultTableModel();
    DefaultTableModel dtmOperadores = new DefaultTableModel();
    DefaultTableModel dtmConstantes = new DefaultTableModel();
    DefaultTableModel dtmErrores = new DefaultTableModel();
    StringBuilder stbTokens = new StringBuilder();
    StringBuilder stbCodigo = new StringBuilder();
    String codigoOptimizado = "";

    // constructor de la ventana
    public AritmeticasTokens() {
        initComponents();
        
        // iniciar tablas
        tablas();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jButton1 = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jScrollPane2 = new javax.swing.JScrollPane();
        jTable1 = new javax.swing.JTable();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jScrollPane3 = new javax.swing.JScrollPane();
        jTable2 = new javax.swing.JTable();
        jLabel4 = new javax.swing.JLabel();
        jScrollPane4 = new javax.swing.JScrollPane();
        jTable3 = new javax.swing.JTable();
        jLabel5 = new javax.swing.JLabel();
        jScrollPane5 = new javax.swing.JScrollPane();
        jTable4 = new javax.swing.JTable();
        jLabel6 = new javax.swing.JLabel();
        jScrollPane6 = new javax.swing.JScrollPane();
        jTextArea2 = new javax.swing.JTextArea();
        jScrollPane7 = new javax.swing.JScrollPane();
        jTable5 = new javax.swing.JTable();
        jLabel7 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jButton1.setText("Analizar");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jLabel1.setText("CÃ³digo");

        jTextArea1.setColumns(20);
        jTextArea1.setRows(5);
        jScrollPane1.setViewportView(jTextArea1);

        jTable1.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        jScrollPane2.setViewportView(jTable1);

        jLabel2.setText("Tabla de simbolos");

        jLabel3.setText("Tabla de Operadores Aritmeticos");

        jTable2.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        jScrollPane3.setViewportView(jTable2);

        jLabel4.setText("Tabla de Constantes");

        jTable3.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        jScrollPane4.setViewportView(jTable3);

        jLabel5.setText("Tabla de errores");

        jTable4.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        jScrollPane5.setViewportView(jTable4);

        jLabel6.setText("Tokens");

        jTextArea2.setColumns(20);
        jTextArea2.setRows(5);
        jScrollPane6.setViewportView(jTextArea2);

        jTable5.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        jScrollPane7.setViewportView(jTable5);

        jLabel7.setText("Tabla de palabras reservadas");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 271, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane6, javax.swing.GroupLayout.PREFERRED_SIZE, 270, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jScrollPane7, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
                            .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
                            .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE))
                        .addContainerGap())
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 99, Short.MAX_VALUE)
                        .addComponent(jLabel3)
                        .addGap(96, 96, 96))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(127, 127, 127)
                                .addComponent(jLabel4))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(131, 131, 131)
                                .addComponent(jLabel2)))
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
            .addGroup(layout.createSequentialGroup()
                .addGap(122, 122, 122)
                .addComponent(jLabel1)
                .addGap(251, 251, 251)
                .addComponent(jLabel6)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jLabel7)
                .addGap(114, 114, 114))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jButton1)
                .addContainerGap())
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jScrollPane4))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jScrollPane5)))
                .addContainerGap())
            .addGroup(layout.createSequentialGroup()
                .addGap(412, 412, 412)
                .addComponent(jLabel5)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 16, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel6)
                    .addComponent(jLabel7))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 380, Short.MAX_VALUE)
                    .addComponent(jScrollPane6)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane7, javax.swing.GroupLayout.PREFERRED_SIZE, 101, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel3)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jLabel4)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jLabel5)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane5, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jButton1)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        // TODO add your handling code here:
        
        // nuevo objeto de tipo token
        tokens = new Token();
        
        // auxiliares para la limpieza de las tablas
        int c = dtmSimbolos.getRowCount();
        int d = dtmOperadores.getRowCount();
        int e = dtmConstantes.getRowCount();
        int f = dtmErrores.getRowCount();
        int p = dtmPalabras.getRowCount();
        
        // se elimina la info de las tablas
        for (int i = 0; i < c; i++) {
            dtmSimbolos.removeRow(0);  
        }
        
        for (int i = 0; i < d; i++) {
            dtmOperadores.removeRow(0);  
        }
        
        for (int i = 0; i < e; i++) {
            dtmConstantes.removeRow(0);  
        }
        
        for (int i = 0; i < f; i++) {
            dtmErrores.removeRow(0);  
        }
        
        for (int i = 0; i < p; i++) {
            dtmPalabras.removeRow(0);  
        }
        
        // se analizan los tokens
        busquedaTokens(jTextArea1.getText());
        
        // si hay codigo escrito, se analiza en busca de errores faltantes y no de identificadores.
        if (!jTextArea1.getText().equals("")) {
            
            // se guarda el codigo de tokens en un auxiliar
            String codigoTokens = imprimirTokens();
            String codigo = jTextArea1.getText();
            
            String[] lineaCodigoTokens;
            String[] lineaCodigo;
            
            /*// se elimina el corchete terminal del cÃ³digo
            if (codigo.contains("}")) {
                StringBuilder stbCodigo = new StringBuilder();
                lineaCodigo = codigo.split("}");
                for(String cod : lineaCodigo) {
                    stbCodigo.append(cod);
                    stbCodigo.deleteCharAt(stbCodigo.length()-1);
                }
                codigo = stbCodigo.toString();
            }*/
            
            // se divide por lineas
            lineaCodigoTokens = codigoTokens.split("\\n");
            lineaCodigo = codigo.split("\\n");
            
            if (lineaCodigo.length == 1) {
                lineaCodigo = codigo.split(";");
                for (int i = 0; i < lineaCodigo.length; i++) {
                    StringBuilder stbLineaCodigo;
                    stbLineaCodigo = new StringBuilder(lineaCodigo[i] + ";");
                    lineaCodigo[i] = stbLineaCodigo.toString();
                }
            }
            
            int numLinea = 0;
            
            try {
                
                // se recorre cada linea
                for (int i = 0; i < lineaCodigoTokens.length; i++) {
                    
                    // apuntador auxiliar y base que servirÃ¡ para buscar el IDE
                    int apunIDE = -1;
                    int apunBase = -1;
                    
                    // el tipo que tiene el identificador auxiliar y base de la operacion
                    String tipoIDE = "null";
                    String tipoBase = "null";
                    String tipoPR = "null";
                    Boolean While = false;
                    
                    // numLinea tiene el numero de linea que estamos trabajando
                    numLinea = i + 1;
                    
                    // elimina los tabs del codigo
                    lineaCodigo[i] = lineaCodigo[i].replace("\t", "");
                    
                    // el codigo esta dividido por espacios, se separan los tokens
                    String[] tempTokens = lineaCodigoTokens[i].split("\\s");
                    String[] tempCodigo = lineaCodigo[i].split("\\s");
                    
                    
                    if(tempCodigo.length == 1) {
                        continue;
                    }
                    
                    // del codigo eliminamos el DEL
                    if (tempTokens.length > 1) {
                        tempCodigo = delDeArr(tempCodigo, tempCodigo.length - 1);
                    }
                    
                    // se verifica si la primera palabra es una palabra reservada
                    if (tempTokens[0].contains("PR")) {
                        
                        String PR = tokens.getValorPR().get(tokens.buscarPR(tempTokens[0]));
                        
                        // primero buscaremos si la primera palabra es una instruccion do
                        if (PR.equalsIgnoreCase("do")) {
                            continue;
                        }
                        
                        if (!PR.equalsIgnoreCase("while")) {
                            tipoPR = PR;

                            if (tempTokens.length > 1) {
                                tempTokens = delDeArr(tempTokens, 0);
                                tempCodigo = delDeArr(tempCodigo, 0);

                                // se verifica que si a continucaciÃ³n hay un IDE, si no se despliega un error y se termina la verificaciÃ³n de lÃ­nea.
                                if(!tempTokens[0].contains("IDE")) {
                                    /*
                                    String valor = "LÃ­nea " +numLinea+ ": La instrucciÃ³n aritmÃ©tica estÃ¡ incorrecta: falta identificador inicial.";
                                    tokens.setELX(valor);
                                    */
                                    continue;
                                }
                            }
                        }
                        else {
                            if (tempTokens.length > 1) {
                                tempTokens = delDeArr(tempTokens, 0);
                                tempCodigo = delDeArr(tempCodigo, 0);
                            }
                            While = true;
                        }
                        
                    }
                    
                    
                    // si el primer token no es un identificador o un error de identificador, se considera un error adicional
                    if (!tempTokens[0].contains("IDE") && !tempTokens[0].contains("ELX") && !tempTokens[0].contains("PR")) {
                        /*
                        String valor = "LÃ­nea " +numLinea+ ": La instrucciÃ³n aritmÃ©tica estÃ¡ incorrecta: falta identificador inicial.";
                        tokens.setELX(valor);
                        */
                    }
                    
                    // en caso contrario se procede a eliminar dicho token
                    else {
                        if (tempTokens.length > 1) {
                            // apuntador auxiliar que servirÃ¡ para buscar el IDE
                            apunBase = tokens.buscarIDE(tempTokens[0]);
                            tempTokens = delDeArr(tempTokens, 0);
                            tempCodigo = delDeArr(tempCodigo, 0);
                        }
                    }
                    
                    // si el identificador inicial no esta declarado
                    if (tokens.getTokenIDE().get(apunBase)[0].equals("null")) {
                        String valor = "LÃ­nea " +numLinea+ ": La instrucciÃ³n aritmÃ©tica estÃ¡ incorrecta: identificador no declarado.";
                        tokens.setEST(valor);
                    }
                    
                    // en caso contrario, almacenar que tipo es
                    else {
                        tipoBase = tokens.getTokenIDE().get(apunBase)[0];
                        
                        // verificamos que no se haya declarado anteriormente
                        if (!tipoPR.equals("null") && !tipoBase.equals(tipoPR)) {
                            String valor = "LÃ­nea " +numLinea+ ": La instrucciÃ³n aritmÃ©tica estÃ¡ incorrecta: declaraciÃ³n duplicada.";
                            tokens.setEST(valor);
                        }
                    }
                    
                    // si el token no es un operador de asignacion o un error de identificador, se considera un errora adicional
                    if (!tempTokens[0].contains("OAS") && !tempTokens[0].contains("OR") && !tempTokens[0].contains("OB") && !tempTokens[0].contains("ELX") && !tempTokens[0].contains("DEL")) {
                        // pero si es un delimitador, se termina la revisiÃ³n de la lÃ­nea.
                        /*
                        String valor = "LÃ­nea " +numLinea+ ": La instrucciÃ³n aritmÃ©tica estÃ¡ incorrecta: falta operador de asignaciÃ³n.";
                        tokens.setELX(valor);
                        */
                    }
                    
                    // en caso contrario se procede a eliminar dicho token
                    else {
                        if (tempTokens.length > 1) {
                            tempTokens = delDeArr(tempTokens, 0);
                            tempCodigo = delDeArr(tempCodigo, 0);
                        }
                    }
                    
                    // si anteriormente no nos encontramos con un DEL, entonces podemos seguir con la verificacion
                    if (tempTokens.length > 1) {
                        // si el token no es un identificador, una constante nÃºmerica, una constante flotante o un error de identificador, se considera un error adicional
                        if (!tempTokens[0].contains("IDE") && !tempTokens[0].contains("CE") && !tempTokens[0].contains("CF") && !tempTokens[0].contains("ELX")) {
                            /*
                            String valor = "LÃ­nea " +numLinea+ ": La instrucciÃ³n aritmÃ©tica estÃ¡ incorrecta: falta operando 1.";
                            tokens.setELX(valor);
                            */
                        }

                        // en caso contrario se procede a verificar el semÃ¡ntico
                        else {
                            // antes se debe verificar
                            // en caso de ser entero la base
                            if (tipoBase.equals("int")) {
                                if (!tempTokens[0].contains("IDE")) {
                                    if (!tempTokens[0].contains("CE")) {
                                        String valor = "LÃ­nea " +numLinea+ ": La instrucciÃ³n aritmÃ©tica estÃ¡ incorrecta: incompatibilidad de tipos.";
                                        tokens.setEST(valor);
                                    }
                                    else {
                                        if (tempTokens[1].contains("DEL") && !tipoBase.equals("null")) {
                                            tokens.actualizarIDE(apunBase, tempCodigo[0]);
                                        }
                                    }
                                }
                                else {
                                    apunIDE = tokens.buscarIDE(tempTokens[0]);
                                    tipoIDE = tokens.getTokenIDE().get(apunIDE)[0];
                                    if (tipoIDE.equals("null")) {
                                        String valor = "LÃ­nea " +numLinea+ ": La instrucciÃ³n aritmÃ©tica estÃ¡ incorrecta: identificador no declarado.";
                                        tokens.setEST(valor);
                                    }
                                    else {
                                        if (tokens.getValorIDE().get(apunIDE)[0].equals("null")) {
                                            String valor = "LÃ­nea " +numLinea+ ": La instrucciÃ³n aritmÃ©tica estÃ¡ incorrecta: identificador no inicializado.";
                                            tokens.setEST(valor);
                                        }
                                        else {
                                            if (!tipoIDE.equals("int")) {
                                                String valor = "LÃ­nea " +numLinea+ ": La instrucciÃ³n aritmÃ©tica estÃ¡ incorrecta: incompatibilidad de tipos.";
                                                tokens.setEST(valor);
                                            }
                                        }
                                    }
                                }
                            }
                            // en caso de no ser entero
                            else {
                                if (tempTokens[0].contains("IDE")) {
                                    apunIDE = tokens.buscarIDE(tempTokens[0]);
                                    tipoIDE = tokens.getValorIDE().get(apunIDE)[0];
                                    if (tipoIDE.equals("null")) {
                                        String valor = "LÃ­nea " +numLinea+ ": La instrucciÃ³n aritmÃ©tica estÃ¡ incorrecta: identificador no inicializado.";
                                        tokens.setEST(valor);
                                    }
                                    else {
                                        if (tempTokens[1].contains("DEL") && !tipoBase.equals("null")) {
                                            tokens.actualizarIDE(apunBase, tempCodigo[0]);
                                        }
                                    }
                                }
                                else {
                                    if (tempTokens[1].contains("DEL") && !tipoBase.equals("null")) {
                                        tokens.actualizarIDE(apunBase, tempCodigo[0]);
                                    }
                                }
                            }
                            
                            // se elimina dicho token
                            if (tempTokens.length > 1) {
                                tempTokens = delDeArr(tempTokens, 0);
                            }
                        }
                        
                        // de nuevo, si no ha habido un DEL anteriormente, se continÃºa la verificaciÃ³n.
                        if (tempTokens.length > 1) {
                            
                            // si el token no es un operador aritmetico o un error de identificador, se considera un errora adicional
                            if (!tempTokens[0].contains("OA") && !tempTokens[0].contains("OR") && !tempTokens[0].contains("OB") && !tempTokens[0].contains("ELX")) {
                                String valor = "LÃ­nea " +numLinea+ ": La instrucciÃ³n aritmÃ©tica estÃ¡ incorrecta: falta operador aritmÃ©tico.";
                                tokens.setELX(valor);
                            }

                            // en caso contrario se procede a eliminar dicho token
                            else {
                                if (tempTokens.length > 1) {
                                    tempTokens = delDeArr(tempTokens, 0);
                                }
                            }

                            // ahora para el resto de la instrucciÃ³n se realiza un nuevo ciclo

                            // en esta variable se guardarÃ¡ el numero de operando
                            int g = 2;

                            // se obtiene el nÃºmero actual de los tokens restantes
                            int k = tempTokens.length;

                            // se recorren los tokens restantes
                            for (int h = 0; h < k; h++) {
                                // si el token no es un identificador, una constante nÃºmerica, una constante flotante o un error de identificador, se considera un error adicional
                                if (!tempTokens[0].contains("IDE") && !tempTokens[0].contains("CE") && !tempTokens[0].contains("CF") && !tempTokens[0].contains("ELX")) {
                                    /*
                                    String valor = "LÃ­nea " +numLinea+ ": La instrucciÃ³n aritmÃ©tica estÃ¡ incorrecta: falta operando " +g+ ".";
                                    tokens.setELX(valor);
                                    */
                                    g++;
                                }
                                
                                // en caso contrario se procede a verificar el semÃ¡ntico
                                else {
                                    // antes se debe verificar
                                    // en caso de ser entero la base
                                    if (tipoBase.equals("int")) {
                                        if (!tempTokens[0].contains("IDE")) {
                                            if (!tempTokens[0].contains("CE")) {
                                                String valor = "LÃ­nea " +numLinea+ ": La instrucciÃ³n aritmÃ©tica estÃ¡ incorrecta: incompatibilidad de tipos.";
                                                tokens.setEST(valor);
                                            }
                                            else {
                                                if (tempTokens[1].contains("DEL") && !tipoBase.equals("null")) {
                                                    tokens.actualizarIDE(apunBase, arregloACodigo(tempCodigo));
                                                }
                                            }
                                        }
                                        else {
                                            apunIDE = tokens.buscarIDE(tempTokens[0]);
                                            tipoIDE = tokens.getTokenIDE().get(apunIDE)[0];
                                            if (tipoIDE.equals("null")) {
                                                String valor = "LÃ­nea " +numLinea+ ": La instrucciÃ³n aritmÃ©tica estÃ¡ incorrecta: identificador no declarado.";
                                                tokens.setEST(valor);
                                            }
                                            else {
                                                if (tokens.getValorIDE().get(apunIDE)[0].equals("null")) {
                                                    String valor = "LÃ­nea " +numLinea+ ": La instrucciÃ³n aritmÃ©tica estÃ¡ incorrecta: identificador no inicializado.";
                                                    tokens.setEST(valor);
                                                }
                                                else {
                                                    if (!tipoIDE.equals("int")) {
                                                        String valor = "LÃ­nea " +numLinea+ ": La instrucciÃ³n aritmÃ©tica estÃ¡ incorrecta: incompatibilidad de tipos.";
                                                        tokens.setEST(valor);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    // en caso de no ser entero
                                    else {
                                        if (tempTokens[0].contains("IDE")) {
                                            apunIDE = tokens.buscarIDE(tempTokens[0]);
                                            tipoIDE = tokens.getValorIDE().get(apunIDE)[0];
                                            if (tipoIDE.equals("null")) {
                                                String valor = "LÃ­nea " +numLinea+ ": La instrucciÃ³n aritmÃ©tica estÃ¡ incorrecta: identificador no inicializado.";
                                                tokens.setEST(valor);
                                            }
                                            else {
                                                if (tempTokens[1].contains("DEL") && !tipoBase.equals("null")) {
                                                    tokens.actualizarIDE(apunBase, arregloACodigo(tempCodigo));
                                                }
                                            }
                                        }
                                        else {
                                            if (tempTokens[1].contains("DEL") && !tipoBase.equals("null")) {
                                                tokens.actualizarIDE(apunBase, arregloACodigo(tempCodigo));
                                            }
                                        }
                                    }

                                    // se elimina dicho token
                                    if (tempTokens.length > 1) {
                                        tempTokens = delDeArr(tempTokens, 0);
                                        g++;
                                    }
                                }

                                // se cambia al siguiente token
                                h++;

                                // si el token no es un operador aritmetico, un delimitador o un error de identificador, se considera un errora adicional
                                if (!tempTokens[0].contains("OA") && !tempTokens[0].contains("DEL") && !tempTokens[0].contains("ELX")) {
                                    /*
                                    String valor = "LÃ­nea " +numLinea+ ": La instrucciÃ³n aritmÃ©tica estÃ¡ incorrecta: falta operador aritmÃ©tico o delimitador.";
                                    tokens.setELX(valor);
                                    */
                                }

                                // en caso contrario se procede a eliminar dicho token
                                else {
                                    // se verifica si se trata de un operador aritmetico
                                    if (tempTokens[0].contains("OA")) {
                                        
                                        // de ser asi, se verifica si se intenta realizar una division
                                        int apunOA = tokens.buscarOA(tempTokens[0]);
                                        if (tokens.getValorOA().get(apunOA).equals("/")) {
                                            // si estamos en una base int, se debe desplegar un error
                                            if(tipoBase.equals("int")) {
                                                String valor = "LÃ­nea " +numLinea+ ": La instrucciÃ³n aritmÃ©tica estÃ¡ incorrecta: incompatibilidad de tipos.";
                                                tokens.setEST(valor);
                                                tokens.actualizarIDE(apunBase, "null");
                                            }
                                        }
                                    }
                                    if (tempTokens.length > 1) {
                                        tempTokens = delDeArr(tempTokens, 0);
                                    }
                                }
                            }
                            
                        }
                        
                    }
                         
                }
            }
            
            catch (ArrayIndexOutOfBoundsException ex) {
                System.out.println("Ãndice del arreglo inalcanzable en la lÃ­nea " + numLinea + " : " +ex.getMessage());
            }
            
        }
        
        // se optimiza el codigo
        optimizarCodigo();
        
        // se escribe el codigo en tokens
        jTextArea2.setText(imprimirTokens());
        
        // se llena la tabla de simbolos
        for (int i = 0; i < tokens.getTokenIDE().size(); i++) {
            dtmSimbolos.addRow(new Object[]{tokens.getTokenIDE().get(i)[0],tokens.getValorIDE().get(i)[1],tokens.getTokenIDE().get(i)[1],tokens.getValorIDE().get(i)[0]});
        }
        
        // se llena la tabla de operadores
        for (int i = 0; i < tokens.getTokenOA().size(); i++) {
            dtmOperadores.addRow(new Object[]{tokens.getValorOA().get(i),tokens.getTokenOA().get(i)});
        }
        
        // se llena la tabla de operadores
        for (int i = 0; i < tokens.getTokenOR().size(); i++) {
            dtmOperadores.addRow(new Object[]{tokens.getValorOR().get(i),tokens.getTokenOR().get(i)});
        }
        
        // se llena la tabla de operadores
        for (int i = 0; i < tokens.getTokenOB().size(); i++) {
            dtmOperadores.addRow(new Object[]{tokens.getValorOB().get(i),tokens.getTokenOB().get(i)});
        }
        
        // se llena la tabla de constantes con los constantes enteros
        for (int i = 0; i < tokens.getTokenCE().size(); i++) {
            dtmConstantes.addRow(new Object[]{tokens.getValorCE().get(i),tokens.getTokenCE().get(i)});
        }
        
        // se llena la tabla de constantes con los constantes flotantes
        for (int i = 0; i < tokens.getTokenCF().size(); i++) {
            dtmConstantes.addRow(new Object[]{tokens.getValorCF().get(i),tokens.getTokenCF().get(i)});
        }
        
        // se llena la tabla de errores
        for (int i = 0; i < tokens.getTokenELX().size(); i++) {
            dtmErrores.addRow(new Object[]{tokens.getTokenELX().get(i),tokens.getValorELX().get(i)});
        }
        for (int i = 0; i < tokens.getTokenEST().size(); i++) {
            dtmErrores.addRow(new Object[]{tokens.getTokenEST().get(i),tokens.getValorEST().get(i)});
        }
        
        // se llena la tabla de palabras
        for (int i = 0; i < tokens.getTokenPR().size(); i++) {
            dtmPalabras.addRow(new Object[]{tokens.getValorPR().get(i),tokens.getTokenPR().get(i)});
        }
        
    }//GEN-LAST:event_jButton1ActionPerformed

    // metodo "busquedaTokens" que sirve para detectar tokens.
    private void busquedaTokens(String input) {
        
        // el stringtokenizer sirve para buscar tokens separados por espacios
        final StringTokenizer st = new StringTokenizer(input);
        
        // esta variable almacena el tipo de variable que se esta guardando.
        String tipo = "null";
        
        // este ciclo recorre todos los tokens
        while (st.hasMoreTokens()) {
            
            // palabra contiene el token a analizar y matched indica si el token existe o no
            String palabra = st.nextToken();
            boolean matched = false;
            
            // se recorren los tipos de token para saber si es un token previamente declarado
            for (Tipo tokenTipo : Tipo.values()) {
                
                // se utilizan las expresiones regulares encontradas en la clase Tipo
                Pattern patron = Pattern.compile(tokenTipo.patron);
                Matcher matcher = patron.matcher(palabra);
                
                // si se concuerda con alguna expresion regular, se verifica con cual y se registra
                if (matcher.find()) {
                    if (tokenTipo.toString().equalsIgnoreCase("PR")) {
                        tokens.setPR(palabra);
                        // matched es true por que el token es correcto
                        matched = true;
                        if (!palabra.equalsIgnoreCase("do") && !palabra.equalsIgnoreCase("while")) {
                            tipo = palabra;
                        }
                        break;
                    }
                    if (tokenTipo.toString().equalsIgnoreCase("IDE")) {
                        tokens.setIDE(palabra, tipo);
                        // matched es true por que el token es correcto
                        matched = true;
                        tipo = "null";
                        break;
                    }
                    if (tokenTipo.toString().equalsIgnoreCase("OA")) {
                        tokens.setOA(palabra);
                        // matched es true por que el token es correcto
                        matched = true;
                        break;
                    }
                    if (tokenTipo.toString().equalsIgnoreCase("OR")) {
                        tokens.setOR(palabra);
                        // matched es true por que el token es correcto
                        matched = true;
                        break;
                    }
                    if (tokenTipo.toString().equalsIgnoreCase("OB")) {
                        tokens.setOB(palabra);
                        // matched es true por que el token es correcto
                        matched = true;
                        break;
                    }
                    if (tokenTipo.toString().equalsIgnoreCase("CE")) {
                        tokens.setCE(palabra);
                        // matched es true por que el token es correcto
                        matched = true;
                        break;
                    }
                    if (tokenTipo.toString().equalsIgnoreCase("CF")) {
                        tokens.setCF(palabra);
                        // matched es true por que el token es correcto
                        matched = true;
                        break;
                    }
                    if (tokenTipo.toString().equalsIgnoreCase("OAS")) {
                        tokens.setOAS();
                        // matched es true por que el token es correcto
                        matched = true;
                        break;
                    }
                    if (tokenTipo.toString().equalsIgnoreCase("SAL1")) {
                        tokens.setSAL1();
                        // matched es true por que el token es correcto
                        matched = true;
                        break;
                    }
                    if (tokenTipo.toString().equalsIgnoreCase("SAL2")) {
                        tokens.setSAL2();
                        // matched es true por que el token es correcto
                        matched = true;
                        break;
                    }
                    if (tokenTipo.toString().equalsIgnoreCase("EXT1")) {
                        tokens.setEXT1();
                        // matched es true por que el token es correcto
                        matched = true;
                        break;
                    }
                    if (tokenTipo.toString().equalsIgnoreCase("EXT2")) {
                        tokens.setEXT2();
                        // matched es true por que el token es correcto
                        matched = true;
                        break;
                    }
                    if (tokenTipo.toString().equalsIgnoreCase("DEL")) {
                        tokens.setDEL();
                        // matched es true por que el token es correcto
                        matched = true;
                        break;
                    }
                    
                }
            }
            
            // pero si no existe el token, se considera un error de identificador mal definido
            if (!matched) {
                String valor = "El identificador " +palabra+ " estÃ¡ mal definido.";
                tokens.setELX(valor);
            }

        }

    }
    
    // metodo del dibujo de tablas
    public void tablas() {
        // se aÃ±aden y se asignan las columnas de cada tabla
        
        dtmPalabras.addColumn("Lexema");
        dtmPalabras.addColumn("Tokens");
        dtmSimbolos.addColumn("Tipo");
        dtmSimbolos.addColumn("Lexema");
        dtmSimbolos.addColumn("Tokens");
        dtmSimbolos.addColumn("Valor");
        dtmOperadores.addColumn("Lexema");
        dtmOperadores.addColumn("Tokens");
        dtmConstantes.addColumn("Lexema");
        dtmConstantes.addColumn("Tokens");
        dtmErrores.addColumn("Clave");
        dtmErrores.addColumn("DescripciÃ³n");

        jTable1.setModel(dtmSimbolos);
        jTable2.setModel(dtmOperadores);
        jTable3.setModel(dtmConstantes);
        jTable4.setModel(dtmErrores);
        jTable5.setModel(dtmPalabras);

    }
    
    // metodo auxiliar para la eliminacion de elementos de un arreglo
    private  static String[] delDeArr (String[] arrayString, int i) {
        
        // se inicializa un nuevo arreglo con un tamaÃ±o menor al existente
        String[] nuevoArray = new String[arrayString.length - 1];
        
        if (i > 0){
            System.arraycopy(arrayString, 0, nuevoArray, 0, i);
        }
        
        if (nuevoArray.length > i){
            System.arraycopy(arrayString, i + 1, nuevoArray, i, nuevoArray.length - i);
        }
        
        return nuevoArray;
    }
    
    // metodo auxiliar para contruir un String a partir de un arreglo
    private static String arregloACodigo (String[] arreglo) {
        StringBuilder stbCodigo = new StringBuilder();
        
        for (int i = 0; i < arreglo.length; i++) {
            stbCodigo.append(arreglo[i]);
            if (i + 1 < arreglo.length) {
                stbCodigo.append(" ");
            }
        }
        
        return stbCodigo.toString();
    }
    
    // metodo para la impresiÃ³n del texto
    private void imprimirTexto(String titulo, String texto) {
        JOptionPane.showMessageDialog(null, texto, titulo, JOptionPane.INFORMATION_MESSAGE);
    }
    
    // metodo para imprimir tokens
    private String imprimirTokens() {
        
        // stringbuilder para traspasar el codigo a tokens
        stbTokens = new StringBuilder();
        
        // en stbtokens se empieza a escribir los tokens que se mostrarÃ¡n en pantalla
        for (int i = 0; i < tokens.getTokenTodo().size(); i++) {
            String a = (tokens.getTokenTodo().get(i));
            String b = a;
            
            if (i > 0) {
                b = (tokens.getTokenTodo().get(i-1));
            }
            
            
            // si hay un delimitador, se hace un salto de linea
            if (a.equalsIgnoreCase("DEL")) {
                stbTokens.append(a);
                stbTokens.append("\n");
            }
            
            // si hay parentesis, se ignora dicho token
            else if (a.equalsIgnoreCase("EXT1")) {
            }
            
            // si hay parentesis, se ignora dicho token
            else if (a.equalsIgnoreCase("EXT2")) {
            }
            
            // si hay parentesis, se ignora dicho token
            else if (a.contains("PR")) {
                if (b.equalsIgnoreCase("EXT2")) {
                    stbTokens.append("\n");
                }
                stbTokens.append(a);
                stbTokens.append(" ");
            }
            
            // si hay corchetes, se hace un salto de linea
            else if (a.equalsIgnoreCase("SAL1")) {
                stbTokens.append("\n");
            }
            
            // si hay corchetes, se hace un salto de linea
            else if (a.equalsIgnoreCase("SAL2")) {
                /*if (!b.equalsIgnoreCase("DEL")) {
                    stbTokens.append("\n");
                }*/
                if (b.equalsIgnoreCase("EXT2")) {
                    stbTokens.append("\n");
                }
                stbTokens.append("\n");
            }
            
            // en caso contrario, se escribe un espacio
            else {
                stbTokens.append(a);
                stbTokens.append(" ");
            }

        }
        
        return stbTokens.toString();
    }
    
    // metodo para la optimizacion de cÃ³digo
    private void optimizarCodigo() {
        // se cargan las listas que contienen los tokens
        ArrayList<String[]> tokenIDE = tokens.getTokenIDE(), valorIDE = tokens.getValorIDE();
        ArrayList<String> tokenTodo = tokens.getTokenTodo(), valorTodo = tokens.getValorTodo();
        
        // se busca en cada IDE si el valor se encuentra duplicado (instruccion 1)
        for(int i = 0; i < valorIDE.size(); i++) {
            
            // no es necesario compararse consigo mismo.
            int j = i + 1;
            while (j < valorIDE.size()) {
                // si el valor del IDE "i" es igual al valor del IDE "j"
                if (valorIDE.get(i)[0].equals(valorIDE.get(j)[0])) {
                    
                    // se reemplaza en el arraylist de todos los tokens
                    for (int k = 0; k < tokenTodo.size(); k++) {
                        if (tokenTodo.get(k).equals(tokenIDE.get(j)[1])) {
                            // si el token anterior es una PR, de igual manera eliminarlo
                            if (tokenTodo.get(k-1).contains("PR")) {
                                while (!tokenTodo.get(k-1).equals("DEL")) {
                                    tokenTodo.remove(k-1);
                                    valorTodo.remove(k-1);
                                }
                                tokenTodo.remove(k-1);
                                valorTodo.remove(k-1);
                            }
                            else if (tokenTodo.get(k-1).contains("DEL")) {
                                while (!tokenTodo.get(k).equals("DEL")) {
                                    tokenTodo.remove(k);
                                    valorTodo.remove(k);
                                }
                                tokenTodo.remove(k);
                                valorTodo.remove(k);
                            }
                            else {
                                // lo que era el token "j" sera el token "i".
                                tokenTodo.set(k, tokenIDE.get(i)[1]);
                                valorTodo.set(k, valorIDE.get(i)[1]);
                            }
                        }
                    }
                    
                    // se elimina de los arraylist
                    tokenIDE.remove(j);
                    valorIDE.remove(j);
                    
                }
                
                j++;
            }
        }
        
        // los cambios se guardan
        tokens.reemplazarIDE(tokenIDE, valorIDE, tokenTodo, valorTodo);
        
        // se hace un stb temporal para el codigo optimizado
        StringBuilder stbOptimizado = new StringBuilder();
        
        // se escribe el cÃ³digo optimizado
        for (int i = 0; i < valorTodo.size(); i++) {
            String a = (tokens.getTokenTodo().get(i));
            String b = a;
            String aValor = (tokens.getValorTodo().get(i));
            String bValor = aValor;
            
            if (i > 0) {
                b = (tokens.getTokenTodo().get(i-1));
                bValor = (tokens.getValorTodo().get(i-1));
            }
            
            
            // si hay un delimitador, se hace un salto de linea
            if (a.equalsIgnoreCase("DEL")) {
                // si no es el Ãºltimo token
                if (i < tokens.getTokenTodo().size()-1) {
                    
                    // verificar que lo que continua del delimitador es un corchete
                    if (tokens.getTokenTodo().get(i+1).equalsIgnoreCase("SAL2")) {
                        
                        // solo se agrega el token
                        stbOptimizado.append(aValor);
                    }
                    else {
                        
                        // en caso contrario se agrega el token y un espacio
                        stbOptimizado.append(aValor);
                        stbOptimizado.append("\n");
                    }
                }
                
                // si es el Ãºltimo agregar el delimitador tal cual.
                else {
                    stbOptimizado.append(aValor);
                }
                
            }
            
            // si hay parentesis, se ignora dicho token
            else if (a.contains("PR")) {
                if (b.equalsIgnoreCase("EXT2")) {
                    stbOptimizado.append("\n");
                }
                stbOptimizado.append(aValor);
                stbOptimizado.append(" ");
            }
            
            // si hay corchetes, se hace un salto de linea
            else if (a.equalsIgnoreCase("SAL1")) {
                stbOptimizado.append("\n");
                stbOptimizado.append(aValor);
            }
            
            // si hay corchetes, se hace un salto de linea
            else if (a.equalsIgnoreCase("SAL2")) {
                stbOptimizado.append(aValor);
                /*if (!b.equalsIgnoreCase("DEL")) {
                    stbTokens.append("\n");
                }*/
                if (b.equalsIgnoreCase("EXT2")) {
                    stbOptimizado.append("\n");
                }
                stbOptimizado.append("\n");
            }
            
            // en caso contrario, se escribe un espacio
            else {
                stbOptimizado.append(aValor);
            }
            
        }
        
        // se guarda el archivo
        guardarArchivo("optimizado.txt", stbOptimizado.toString());
    }
    
    public void guardarArchivo(String archivoExtension, String texto) {
        
        try {
            FileWriter fw = new FileWriter(archivoExtension);
            fw.write(texto);
            fw.close();
            JOptionPane.showConfirmDialog(null, "El archivo ''" +archivoExtension+ "'' ha sido guardado con Ã©xito.", "Archivo guardado con Ã©xito", JOptionPane.DEFAULT_OPTION, JOptionPane.INFORMATION_MESSAGE);
        }
        catch (IOException ex) {
            
        }
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(AritmeticasTokens.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(AritmeticasTokens.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(AritmeticasTokens.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(AritmeticasTokens.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new AritmeticasTokens().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JScrollPane jScrollPane5;
    private javax.swing.JScrollPane jScrollPane6;
    private javax.swing.JScrollPane jScrollPane7;
    private javax.swing.JTable jTable1;
    private javax.swing.JTable jTable2;
    private javax.swing.JTable jTable3;
    private javax.swing.JTable jTable4;
    private javax.swing.JTable jTable5;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JTextArea jTextArea2;
    // End of variables declaration//GEN-END:variables
}
