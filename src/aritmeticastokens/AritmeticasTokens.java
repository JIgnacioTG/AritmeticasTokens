package aritmeticastokens;

// librerias
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.EmptyStackException;
import java.util.NoSuchElementException;
import java.util.Stack;
import java.util.StringTokenizer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.swing.JOptionPane;
import javax.swing.table.DefaultTableModel;

public class AritmeticasTokens extends javax.swing.JFrame {
    
    // declaracion de variables
    Token tokens = new Token();
    ArrayList<String> tipo = new ArrayList<>();
    ArrayList<String> tipotoken = new ArrayList<>();
    ArrayList<String> errores = new ArrayList<>();
    ArrayList<Integer> column1;
    ArrayList<String> column2;
    ArrayList<String> column3;
    ArrayList<String> column4;
    ArrayList<Integer> posDo;
    ArrayList<Integer> posWhile;
    DefaultTableModel dtmPalabras = new DefaultTableModel();
    DefaultTableModel dtmSimbolos = new DefaultTableModel();
    DefaultTableModel dtmOperadores = new DefaultTableModel();
    DefaultTableModel dtmConstantes = new DefaultTableModel();
    DefaultTableModel dtmErrores = new DefaultTableModel();
    StringBuilder stbTokens = new StringBuilder();
    StringBuilder stbCodigo = new StringBuilder();
    String codigoOptimizado = "";
    String saltoLn = System.getProperty("line.separator");

    // constructor de la ventana
    public AritmeticasTokens() {
        initComponents();
        
        // iniciar tablas
        tablas();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jButton1 = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jScrollPane2 = new javax.swing.JScrollPane();
        jTable1 = new javax.swing.JTable();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jScrollPane3 = new javax.swing.JScrollPane();
        jTable2 = new javax.swing.JTable();
        jLabel4 = new javax.swing.JLabel();
        jScrollPane4 = new javax.swing.JScrollPane();
        jTable3 = new javax.swing.JTable();
        jLabel5 = new javax.swing.JLabel();
        jScrollPane5 = new javax.swing.JScrollPane();
        jTable4 = new javax.swing.JTable();
        jLabel6 = new javax.swing.JLabel();
        jScrollPane6 = new javax.swing.JScrollPane();
        jTextArea2 = new javax.swing.JTextArea();
        jScrollPane7 = new javax.swing.JScrollPane();
        jTable5 = new javax.swing.JTable();
        jLabel7 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jButton1.setText("Analizar");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jLabel1.setText("Código");

        jTextArea1.setColumns(20);
        jTextArea1.setRows(5);
        jScrollPane1.setViewportView(jTextArea1);

        jTable1.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        jScrollPane2.setViewportView(jTable1);

        jLabel2.setText("Tabla de simbolos");

        jLabel3.setText("Tabla de Operadores Aritmeticos");

        jTable2.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        jScrollPane3.setViewportView(jTable2);

        jLabel4.setText("Tabla de Constantes");

        jTable3.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        jScrollPane4.setViewportView(jTable3);

        jLabel5.setText("Tabla de errores");

        jTable4.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        jScrollPane5.setViewportView(jTable4);

        jLabel6.setText("Tokens");

        jTextArea2.setColumns(20);
        jTextArea2.setRows(5);
        jScrollPane6.setViewportView(jTextArea2);

        jTable5.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        jScrollPane7.setViewportView(jTable5);

        jLabel7.setText("Tabla de palabras reservadas");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 271, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane6, javax.swing.GroupLayout.PREFERRED_SIZE, 270, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jScrollPane7, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
                            .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
                            .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE))
                        .addContainerGap())
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 99, Short.MAX_VALUE)
                        .addComponent(jLabel3)
                        .addGap(96, 96, 96))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(127, 127, 127)
                                .addComponent(jLabel4))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(131, 131, 131)
                                .addComponent(jLabel2)))
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
            .addGroup(layout.createSequentialGroup()
                .addGap(122, 122, 122)
                .addComponent(jLabel1)
                .addGap(251, 251, 251)
                .addComponent(jLabel6)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jLabel7)
                .addGap(114, 114, 114))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jButton1)
                .addContainerGap())
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jScrollPane4))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jScrollPane5)))
                .addContainerGap())
            .addGroup(layout.createSequentialGroup()
                .addGap(412, 412, 412)
                .addComponent(jLabel5)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 16, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel6)
                    .addComponent(jLabel7))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 380, Short.MAX_VALUE)
                    .addComponent(jScrollPane6)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane7, javax.swing.GroupLayout.PREFERRED_SIZE, 101, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel3)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jLabel4)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jLabel5)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane5, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jButton1)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        // TODO add your handling code here:
        
        // nuevo column2 de tipo token
        tokens = new Token();
        
        // auxiliares para la limpieza de las tablas
        int c = dtmSimbolos.getRowCount();
        int d = dtmOperadores.getRowCount();
        int e = dtmConstantes.getRowCount();
        int f = dtmErrores.getRowCount();
        int p = dtmPalabras.getRowCount();
        
        // se elimina la info de las tablas
        for (int i = 0; i < c; i++) {
            dtmSimbolos.removeRow(0);  
        }
        
        for (int i = 0; i < d; i++) {
            dtmOperadores.removeRow(0);  
        }
        
        for (int i = 0; i < e; i++) {
            dtmConstantes.removeRow(0);  
        }
        
        for (int i = 0; i < f; i++) {
            dtmErrores.removeRow(0);  
        }
        
        for (int i = 0; i < p; i++) {
            dtmPalabras.removeRow(0);  
        }
        
        // se analizan los tokens
        busquedaTokens(jTextArea1.getText());
        
        // si hay codigo escrito, se analiza en busca de errores faltantes y no de identificadores.
        if (!jTextArea1.getText().equals("")) {
            
            // se guarda el codigo de tokens en un auxiliar
            String codigoTokens = imprimirTokens();
            String codigo = jTextArea1.getText();
            
            String[] lineaCodigoTokens;
            String[] lineaCodigo;
            
            /*// se elimina el corchete terminal del código
            if (codigo.contains("}")) {
                StringBuilder stbCodigo = new StringBuilder();
                lineaCodigo = codigo.split("}");
                for(String cod : lineaCodigo) {
                    stbCodigo.append(cod);
                    stbCodigo.deleteCharAt(stbCodigo.length()-1);
                }
                codigo = stbCodigo.toString();
            }*/
            
            // se divide por lineas
            lineaCodigoTokens = codigoTokens.split("\\n");
            lineaCodigo = codigo.split("\\n");
            
            if (lineaCodigo.length == 1) {
                lineaCodigo = codigo.split(";");
                for (int i = 0; i < lineaCodigo.length; i++) {
                    StringBuilder stbLineaCodigo;
                    stbLineaCodigo = new StringBuilder(lineaCodigo[i] + ";");
                    lineaCodigo[i] = stbLineaCodigo.toString();
                }
            }
            
            int numLinea = 0;
            
            // se recorre cada linea
            for (int i = 0; i < lineaCodigoTokens.length; i++) {
            
                try {
                
                    // apuntador auxiliar y base que servirá para buscar el IDE
                    int apunIDE = -1;
                    int apunBase = -1;
                    
                    // el tipo que tiene el identificador auxiliar y base de la operacion
                    String tipoIDE = "null";
                    String tipoBase = "null";
                    String tipoPR = "null";
                    
                    // numLinea tiene el numero de linea que estamos trabajando
                    numLinea = i + 1;
                    
                    // elimina los tabs del codigo
                    lineaCodigo[i] = lineaCodigo[i].replace("\t", "");
                    
                    // el codigo esta dividido por espacios, se separan los tokens
                    String[] tempTokens = lineaCodigoTokens[i].split("\\s");
                    String[] tempCodigo = lineaCodigo[i].split("\\s");
                    
                    // booleano que ayuda identificar si la linea es un while
                    Boolean isWhile = false;
                    
                    if(tempCodigo.length == 1) {
                        continue;
                    }
                    
                    // del codigo eliminamos el DEL
                    if (tempTokens.length > 1) {
                        tempCodigo = delDeArr(tempCodigo, tempCodigo.length - 1);
                    }
                    
                    // se verifica si la primera palabra es una palabra reservada
                    if (tempTokens[0].contains("PR")) {
                        
                        String PR = tokens.getValorPR().get(tokens.buscarPR(tempTokens[0]));
                        
                        // primero buscaremos si la primera palabra es una instruccion do
                        if (PR.equalsIgnoreCase("do")) {
                            continue;
                        }
                        
                        if (!PR.equalsIgnoreCase("while")) {
                            tipoPR = PR;

                            if (tempTokens.length > 1) {
                                tempTokens = delDeArr(tempTokens, 0);
                                tempCodigo = delDeArr(tempCodigo, 0);

                                // se verifica que si a continucación hay un IDE, si no se despliega un error y se termina la verificación de línea.
                                if(!tempTokens[0].contains("IDE")) {
                                    /*
                                    String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: falta identificador inicial.";
                                    tokens.setELX(valor);
                                    */
                                    continue;
                                }
                            }
                        }
                        else {
                            if (tempTokens.length > 1) {
                                tempTokens = delDeArr(tempTokens, 0);
                                tempCodigo = delDeArr(tempCodigo, 0);
                            }
                            isWhile = true;
                        }
                        
                    }
                    
                    
                    // si el primer token no es un identificador o un error de identificador, se considera un error adicional
                    if (!tempTokens[0].contains("IDE") && !tempTokens[0].contains("ELX") && !tempTokens[0].contains("PR")) {
                        /*
                        String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: falta identificador inicial.";
                        tokens.setELX(valor);
                        */
                    }
                    
                    // en caso contrario se procede a eliminar dicho token
                    else {
                        if (tempTokens.length > 1) {
                            // apuntador auxiliar que servirá para buscar el IDE
                            apunBase = tokens.buscarIDE(tempTokens[0]);
                            tempTokens = delDeArr(tempTokens, 0);
                            tempCodigo = delDeArr(tempCodigo, 0);
                        }
                    }
                    
                    // si el identificador inicial no esta declarado
                    if (tokens.getTokenIDE().get(apunBase)[0].equals("null")) {
                        String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: identificador no declarado.";
                        tokens.setEST(valor);
                    }
                    
                    // en caso contrario, almacenar que tipo es
                    else {
                        tipoBase = tokens.getTokenIDE().get(apunBase)[0];
                        
                        // verificamos que no se haya declarado anteriormente
                        if (!tipoPR.equals("null") && !tipoBase.equals(tipoPR)) {
                            String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: declaración duplicada.";
                            tokens.setEST(valor);
                        }
                    }
                    
                    // si el token no es un operador de asignacion o un error de identificador, se considera un errora adicional
                    if (!tempTokens[0].contains("OAS") && !tempTokens[0].contains("OR") && !tempTokens[0].contains("OB") && !tempTokens[0].contains("ELX") && !tempTokens[0].contains("DEL")) {
                        // pero si es un delimitador, se termina la revisión de la línea.
                        /*
                        String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: falta operador de asignación.";
                        tokens.setELX(valor);
                        */
                    }
                    
                    // en caso contrario se procede a eliminar dicho token
                    else {
                        if (tempTokens.length > 1) {
                            tempTokens = delDeArr(tempTokens, 0);
                            tempCodigo = delDeArr(tempCodigo, 0);
                        }
                    }
                    
                    // si anteriormente no nos encontramos con un DEL, entonces podemos seguir con la verificacion
                    if (tempTokens.length > 1) {
                        // si el token no es un identificador, una constante númerica, una constante flotante o un error de identificador, se considera un error adicional
                        if (!tempTokens[0].contains("IDE") && !tempTokens[0].contains("CE") && !tempTokens[0].contains("CF") && !tempTokens[0].contains("ELX")) {
                            /*
                            String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: falta operando 1.";
                            tokens.setELX(valor);
                            */
                        }

                        // en caso contrario se procede a verificar el semántico
                        else {
                            // antes se debe verificar
                            // en caso de ser entero la base
                            if (tipoBase.equals("int") && !isWhile) {
                                if (!tempTokens[0].contains("IDE")) {
                                    if (!tempTokens[0].contains("CE")) {
                                        String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: incompatibilidad de tipos.";
                                        tokens.setEST(valor);
                                    }
                                    else {
                                        if (tempTokens[1].contains("DEL") && !tipoBase.equals("null")) {
                                            tokens.actualizarIDE(apunBase, tempCodigo[0]);
                                        }
                                    }
                                }
                                else {
                                    apunIDE = tokens.buscarIDE(tempTokens[0]);
                                    tipoIDE = tokens.getTokenIDE().get(apunIDE)[0];
                                    if (tipoIDE.equals("null")) {
                                        String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: identificador no declarado.";
                                        tokens.setEST(valor);
                                    }
                                    else {
                                        if (tokens.getValorIDE().get(apunIDE)[0].equals("null")) {
                                            String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: identificador no inicializado.";
                                            tokens.setEST(valor);
                                        }
                                        else {
                                            if (!tipoIDE.equals("int")) {
                                                String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: incompatibilidad de tipos.";
                                                tokens.setEST(valor);
                                            }
                                        }
                                    }
                                }
                            }
                            // en caso de no ser entero
                            else {
                                if (tempTokens[0].contains("IDE")) {
                                    apunIDE = tokens.buscarIDE(tempTokens[0]);
                                    tipoIDE = tokens.getValorIDE().get(apunIDE)[0];
                                    if (tipoIDE.equals("null")) {
                                        String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: identificador no inicializado.";
                                        tokens.setEST(valor);
                                    }
                                    else {
                                        if (tempTokens[1].contains("DEL") && !tipoBase.equals("null")) {
                                            tokens.actualizarIDE(apunBase, tempCodigo[0]);
                                        }
                                    }
                                }
                                else {
                                    if (tempTokens[1].contains("DEL") && !tipoBase.equals("null")) {
                                        tokens.actualizarIDE(apunBase, tempCodigo[0]);
                                    }
                                }
                            }
                            
                            // se elimina dicho token
                            if (tempTokens.length > 1) {
                                tempTokens = delDeArr(tempTokens, 0);
                            }
                        }
                        
                        // de nuevo, si no ha habido un DEL anteriormente, se continúa la verificación.
                        if (tempTokens.length > 1) {
                            
                            // si el token no es un operador aritmetico o un error de identificador, se considera un errora adicional
                            if (!tempTokens[0].contains("OA") && !tempTokens[0].contains("OR") && !tempTokens[0].contains("OB") && !tempTokens[0].contains("ELX")) {
                                String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: falta operador aritmético.";
                                tokens.setELX(valor);
                            }

                            // en caso contrario se procede a eliminar dicho token
                            else {
                                if (tempTokens.length > 1) {
                                    tempTokens = delDeArr(tempTokens, 0);
                                }
                            }

                            // ahora para el resto de la instrucción se realiza un nuevo ciclo

                            // en esta variable se guardará el numero de operando
                            int g = 2;

                            // se obtiene el número actual de los tokens restantes
                            int k = tempTokens.length;

                            // se recorren los tokens restantes
                            for (int h = 0; h < k; h++) {
                                // si el token no es un identificador, una constante númerica, una constante flotante o un error de identificador, se considera un error adicional
                                if (!tempTokens[0].contains("IDE") && !tempTokens[0].contains("CE") && !tempTokens[0].contains("CF") && !tempTokens[0].contains("ELX")) {
                                    /*
                                    String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: falta operando " +g+ ".";
                                    tokens.setELX(valor);
                                    */
                                    g++;
                                }
                                
                                // en caso contrario se procede a verificar el semántico
                                else {
                                    // antes se debe verificar
                                    // en caso de ser entero la base
                                    if (tipoBase.equals("int") && !isWhile) {
                                        if (!tempTokens[0].contains("IDE")) {
                                            if (!tempTokens[0].contains("CE")) {
                                                String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: incompatibilidad de tipos.";
                                                tokens.setEST(valor);
                                            }
                                            else {
                                                if (tempTokens[1].contains("DEL") && !tipoBase.equals("null")) {
                                                    tokens.actualizarIDE(apunBase, arregloACodigo(tempCodigo));
                                                }
                                            }
                                        }
                                        else {
                                            apunIDE = tokens.buscarIDE(tempTokens[0]);
                                            tipoIDE = tokens.getTokenIDE().get(apunIDE)[0];
                                            if (tipoIDE.equals("null")) {
                                                String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: identificador no declarado.";
                                                tokens.setEST(valor);
                                            }
                                            else {
                                                if (tokens.getValorIDE().get(apunIDE)[0].equals("null")) {
                                                    String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: identificador no inicializado.";
                                                    tokens.setEST(valor);
                                                }
                                                else {
                                                    if (!tipoIDE.equals("int")) {
                                                        String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: incompatibilidad de tipos.";
                                                        tokens.setEST(valor);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    // en caso de no ser entero
                                    else {
                                        if (tempTokens[0].contains("IDE")) {
                                            apunIDE = tokens.buscarIDE(tempTokens[0]);
                                            tipoIDE = tokens.getValorIDE().get(apunIDE)[0];
                                            if (tipoIDE.equals("null")) {
                                                String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: identificador no inicializado.";
                                                tokens.setEST(valor);
                                            }
                                            else {
                                                if (tempTokens[1].contains("DEL") && !tipoBase.equals("null")) {
                                                    tokens.actualizarIDE(apunBase, arregloACodigo(tempCodigo));
                                                }
                                            }
                                        }
                                        else {
                                            if (tempTokens[1].contains("DEL") && !tipoBase.equals("null")) {
                                                tokens.actualizarIDE(apunBase, arregloACodigo(tempCodigo));
                                            }
                                        }
                                    }

                                    // se elimina dicho token
                                    if (tempTokens.length > 1) {
                                        tempTokens = delDeArr(tempTokens, 0);
                                        g++;
                                    }
                                }

                                // se cambia al siguiente token
                                h++;

                                // si el token no es un operador aritmetico, un delimitador o un error de identificador, se considera un errora adicional
                                if (!tempTokens[0].contains("OA") && !tempTokens[0].contains("DEL") && !tempTokens[0].contains("ELX")) {
                                    /*
                                    String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: falta operador aritmético o delimitador.";
                                    tokens.setELX(valor);
                                    */
                                }

                                // en caso contrario se procede a eliminar dicho token
                                else {
                                    // se verifica si se trata de un operador aritmetico
                                    if (tempTokens[0].contains("OA")) {
                                        
                                        // de ser asi, se verifica si se intenta realizar una division
                                        int apunOA = tokens.buscarOA(tempTokens[0]);
                                        if (tokens.getValorOA().get(apunOA).equals("/")) {
                                            // si estamos en una base int, se debe desplegar un error
                                            if(tipoBase.equals("int")) {
                                                String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: incompatibilidad de tipos.";
                                                tokens.setEST(valor);
                                                tokens.actualizarIDE(apunBase, "null");
                                            }
                                        }
                                    }
                                    if (tempTokens.length > 1) {
                                        tempTokens = delDeArr(tempTokens, 0);
                                    }
                                }
                            }
                            
                        }
                        
                    }
                         
                }
                
                catch (ArrayIndexOutOfBoundsException ex) {
                    System.out.println("Índice del arreglo inalcanzable en la línea " + numLinea + " : " +ex.getMessage());
                }
            }
            
        }
        
        // se optimiza el codigo
        optimizarCodigo();
        
        // se genera el codigo intermedio
        generarIntermedio();
        
        // se genera el codigo objeto
        generarObjeto();
        
        // se escribe el codigo en tokens
        jTextArea2.setText(imprimirTokens());
        
        // se llena la tabla de simbolos
        for (int i = 0; i < tokens.getTokenIDE().size(); i++) {
            dtmSimbolos.addRow(new Object[]{tokens.getTokenIDE().get(i)[0],tokens.getValorIDE().get(i)[1],tokens.getTokenIDE().get(i)[1],tokens.getValorIDE().get(i)[0]});
        }
        
        // se llena la tabla de operadores
        for (int i = 0; i < tokens.getTokenOA().size(); i++) {
            dtmOperadores.addRow(new Object[]{tokens.getValorOA().get(i),tokens.getTokenOA().get(i)});
        }
        
        // se llena la tabla de operadores
        for (int i = 0; i < tokens.getTokenOR().size(); i++) {
            dtmOperadores.addRow(new Object[]{tokens.getValorOR().get(i),tokens.getTokenOR().get(i)});
        }
        
        // se llena la tabla de operadores
        for (int i = 0; i < tokens.getTokenOB().size(); i++) {
            dtmOperadores.addRow(new Object[]{tokens.getValorOB().get(i),tokens.getTokenOB().get(i)});
        }
        
        // se llena la tabla de constantes con los constantes enteros
        for (int i = 0; i < tokens.getTokenCE().size(); i++) {
            dtmConstantes.addRow(new Object[]{tokens.getValorCE().get(i),tokens.getTokenCE().get(i)});
        }
        
        // se llena la tabla de constantes con los constantes flotantes
        for (int i = 0; i < tokens.getTokenCF().size(); i++) {
            dtmConstantes.addRow(new Object[]{tokens.getValorCF().get(i),tokens.getTokenCF().get(i)});
        }
        
        // se llena la tabla de errores
        for (int i = 0; i < tokens.getTokenELX().size(); i++) {
            dtmErrores.addRow(new Object[]{tokens.getTokenELX().get(i),tokens.getValorELX().get(i)});
        }
        for (int i = 0; i < tokens.getTokenEST().size(); i++) {
            dtmErrores.addRow(new Object[]{tokens.getTokenEST().get(i),tokens.getValorEST().get(i)});
        }
        
        // se llena la tabla de palabras
        for (int i = 0; i < tokens.getTokenPR().size(); i++) {
            dtmPalabras.addRow(new Object[]{tokens.getValorPR().get(i),tokens.getTokenPR().get(i)});
        }
        
    }//GEN-LAST:event_jButton1ActionPerformed

    // metodo "busquedaTokens" que sirve para detectar tokens.
    private void busquedaTokens(String input) {
        
        // el stringtokenizer sirve para buscar tokens separados por espacios
        final StringTokenizer st = new StringTokenizer(input);
        
        // esta variable almacena el tipo de variable que se esta guardando.
        String tipo = "null";
        
        // este ciclo recorre todos los tokens
        while (st.hasMoreTokens()) {
            
            // palabra contiene el token a analizar y matched indica si el token existe o no
            String palabra = st.nextToken();
            boolean matched = false;
            
            // se recorren los tipos de token para saber si es un token previamente declarado
            for (Tipo tokenTipo : Tipo.values()) {
                
                // se utilizan las expresiones regulares encontradas en la clase Tipo
                Pattern patron = Pattern.compile(tokenTipo.patron);
                Matcher matcher = patron.matcher(palabra);
                
                // si se concuerda con alguna expresion regular, se verifica con cual y se registra
                if (matcher.find()) {
                    if (tokenTipo.toString().equalsIgnoreCase("PR")) {
                        tokens.setPR(palabra);
                        // matched es true por que el token es correcto
                        matched = true;
                        if (!palabra.equalsIgnoreCase("do") && !palabra.equalsIgnoreCase("while")) {
                            tipo = palabra;
                        }
                        break;
                    }
                    if (tokenTipo.toString().equalsIgnoreCase("IDE")) {
                        tokens.setIDE(palabra, tipo);
                        // matched es true por que el token es correcto
                        matched = true;
                        tipo = "null";
                        break;
                    }
                    if (tokenTipo.toString().equalsIgnoreCase("OA")) {
                        tokens.setOA(palabra);
                        // matched es true por que el token es correcto
                        matched = true;
                        break;
                    }
                    if (tokenTipo.toString().equalsIgnoreCase("OR")) {
                        tokens.setOR(palabra);
                        // matched es true por que el token es correcto
                        matched = true;
                        break;
                    }
                    if (tokenTipo.toString().equalsIgnoreCase("OB")) {
                        tokens.setOB(palabra);
                        // matched es true por que el token es correcto
                        matched = true;
                        break;
                    }
                    if (tokenTipo.toString().equalsIgnoreCase("CE")) {
                        tokens.setCE(palabra);
                        // matched es true por que el token es correcto
                        matched = true;
                        break;
                    }
                    if (tokenTipo.toString().equalsIgnoreCase("CF")) {
                        tokens.setCF(palabra);
                        // matched es true por que el token es correcto
                        matched = true;
                        break;
                    }
                    if (tokenTipo.toString().equalsIgnoreCase("OAS")) {
                        tokens.setOAS();
                        // matched es true por que el token es correcto
                        matched = true;
                        break;
                    }
                    if (tokenTipo.toString().equalsIgnoreCase("SAL1")) {
                        tokens.setSAL1();
                        // matched es true por que el token es correcto
                        matched = true;
                        break;
                    }
                    if (tokenTipo.toString().equalsIgnoreCase("SAL2")) {
                        tokens.setSAL2();
                        // matched es true por que el token es correcto
                        matched = true;
                        break;
                    }
                    if (tokenTipo.toString().equalsIgnoreCase("EXT1")) {
                        tokens.setEXT1();
                        // matched es true por que el token es correcto
                        matched = true;
                        break;
                    }
                    if (tokenTipo.toString().equalsIgnoreCase("EXT2")) {
                        tokens.setEXT2();
                        // matched es true por que el token es correcto
                        matched = true;
                        break;
                    }
                    if (tokenTipo.toString().equalsIgnoreCase("DEL")) {
                        tokens.setDEL();
                        // matched es true por que el token es correcto
                        matched = true;
                        break;
                    }
                    
                }
            }
            
            // pero si no existe el token, se considera un error de identificador mal definido
            if (!matched) {
                String valor = "El identificador " +palabra+ " está mal definido.";
                tokens.setELX(valor);
            }

        }

    }
    
    // metodo del dibujo de tablas
    public void tablas() {
        // se añaden y se asignan las columnas de cada tabla
        
        dtmPalabras.addColumn("Lexema");
        dtmPalabras.addColumn("Tokens");
        dtmSimbolos.addColumn("Tipo");
        dtmSimbolos.addColumn("Lexema");
        dtmSimbolos.addColumn("Tokens");
        dtmSimbolos.addColumn("Valor");
        dtmOperadores.addColumn("Lexema");
        dtmOperadores.addColumn("Tokens");
        dtmConstantes.addColumn("Lexema");
        dtmConstantes.addColumn("Tokens");
        dtmErrores.addColumn("Clave");
        dtmErrores.addColumn("Descripción");

        jTable1.setModel(dtmSimbolos);
        jTable2.setModel(dtmOperadores);
        jTable3.setModel(dtmConstantes);
        jTable4.setModel(dtmErrores);
        jTable5.setModel(dtmPalabras);

    }
    
    // metodo auxiliar para la eliminacion de elementos de un arreglo
    private  static String[] delDeArr (String[] arrayString, int i) {
        
        // se inicializa un nuevo arreglo con un tamaño menor al existente
        String[] nuevoArray = new String[arrayString.length - 1];
        
        if (i > 0){
            System.arraycopy(arrayString, 0, nuevoArray, 0, i);
        }
        
        if (nuevoArray.length > i){
            System.arraycopy(arrayString, i + 1, nuevoArray, i, nuevoArray.length - i);
        }
        
        return nuevoArray;
    }
    
    // metodo auxiliar para contruir un String a partir de un arreglo
    private static String arregloACodigo (String[] arreglo) {
        StringBuilder stbCodigo = new StringBuilder();
        
        for (int i = 0; i < arreglo.length; i++) {
            stbCodigo.append(arreglo[i]);
            if (i + 1 < arreglo.length) {
                stbCodigo.append(" ");
            }
        }
        
        return stbCodigo.toString();
    }
    
    // metodo para la impresión del texto
    private void imprimirTexto(String titulo, String texto) {
        JOptionPane.showMessageDialog(null, texto, titulo, JOptionPane.INFORMATION_MESSAGE);
    }
    
    // metodo para imprimir tokens
    private String imprimirTokens() {
        
        // stringbuilder para traspasar el codigo a tokens
        stbTokens = new StringBuilder();
        
        // en stbtokens se empieza a escribir los tokens que se mostrarán en pantalla
        for (int i = 0; i < tokens.getTokenTodo().size(); i++) {
            String a = (tokens.getTokenTodo().get(i));
            String b = a;
            
            if (i > 0) {
                b = (tokens.getTokenTodo().get(i-1));
            }
            
            
            // si hay un delimitador, se hace un salto de linea
            if (a.equalsIgnoreCase("DEL")) {
                stbTokens.append(a);
                stbTokens.append(saltoLn);
            }
            
            // si hay parentesis, se ignora dicho token
            else if (a.equalsIgnoreCase("EXT1")) {
            }
            
            // si hay parentesis, se ignora dicho token
            else if (a.equalsIgnoreCase("EXT2")) {
            }
            
            // si hay parentesis, se ignora dicho token
            else if (a.contains("PR")) {
                if (b.equalsIgnoreCase("EXT2")) {
                    stbTokens.append(saltoLn);
                }
                stbTokens.append(a);
                stbTokens.append(" ");
            }
            
            // si hay corchetes, se hace un salto de linea
            else if (a.equalsIgnoreCase("SAL1")) {
                stbTokens.append(saltoLn);
            }
            
            // si hay corchetes, se hace un salto de linea
            else if (a.equalsIgnoreCase("SAL2")) {
                /*if (!b.equalsIgnoreCase("DEL")) {
                    stbTokens.append(saltoLn);
                }*/
                if (b.equalsIgnoreCase("EXT2")) {
                    stbTokens.append(saltoLn);
                }
                stbTokens.append(saltoLn);
            }
            
            // en caso contrario, se escribe un espacio
            else {
                stbTokens.append(a);
                stbTokens.append(" ");
            }

        }
        
        return stbTokens.toString();
    }
    
    // metodo para la optimizacion de código
    private void optimizarCodigo() {
        // se cargan las listas que contienen los tokens
        ArrayList<String[]> tokenIDE = tokens.getTokenIDE(), valorIDE = tokens.getValorIDE();
        ArrayList<String> tokenTodo = tokens.getTokenTodo(), valorTodo = tokens.getValorTodo();
        
        // se busca en cada IDE si el valor se encuentra duplicado (instruccion 1)
        for(int i = 0; i < valorIDE.size(); i++) {
            
            // no es necesario compararse consigo mismo.
            int j = i + 1;
            while (j < valorIDE.size()) {
                // si el valor del IDE "i" es igual al valor del IDE "j"
                if (valorIDE.get(i)[0].equals(valorIDE.get(j)[0])) {
                    
                    // se reemplaza en el arraylist de todos los tokens
                    for (int k = 0; k < tokenTodo.size(); k++) {
                        if (tokenTodo.get(k).equals(tokenIDE.get(j)[1])) {
                            // si el token anterior es una PR, de igual manera eliminarlo
                            if (tokenTodo.get(k-1).contains("PR")) {
                                while (!tokenTodo.get(k-1).equals("DEL")) {
                                    tokenTodo.remove(k-1);
                                    valorTodo.remove(k-1);
                                }
                                tokenTodo.remove(k-1);
                                valorTodo.remove(k-1);
                            }
                            else if (tokenTodo.get(k-1).contains("DEL")) {
                                while (!tokenTodo.get(k).equals("DEL")) {
                                    tokenTodo.remove(k);
                                    valorTodo.remove(k);
                                }
                                tokenTodo.remove(k);
                                valorTodo.remove(k);
                            }
                            else {
                                // lo que era el token "j" sera el token "i".
                                tokenTodo.set(k, tokenIDE.get(i)[1]);
                                valorTodo.set(k, valorIDE.get(i)[1]);
                            }
                        }
                    }
                    
                    // se elimina de los arraylist
                    tokenIDE.remove(j);
                    valorIDE.remove(j);
                    
                }
                
                j++;
            }
        }
        
        // los cambios se guardan
        tokens.reemplazarIDE(tokenIDE, valorIDE, tokenTodo, valorTodo);
        
        // se hace un stb temporal para el codigo optimizado
        StringBuilder stbOptimizado = new StringBuilder();
        
        // se escribe el código optimizado
        for (int i = 0; i < valorTodo.size(); i++) {
            String a = (tokens.getTokenTodo().get(i));
            String b = a;
            String aValor = (tokens.getValorTodo().get(i));
            String bValor = aValor;
            
            if (i > 0) {
                b = (tokens.getTokenTodo().get(i-1));
                bValor = (tokens.getValorTodo().get(i-1));
            }
            
            
            // si hay un delimitador, se hace un salto de linea
            if (a.equalsIgnoreCase("DEL")) {
                // si no es el último token
                if (i < tokens.getTokenTodo().size()-1) {
                    
                    // verificar que lo que continua del delimitador es un corchete
                    if (tokens.getTokenTodo().get(i+1).equalsIgnoreCase("SAL2")) {
                        
                        // solo se agrega el token
                        stbOptimizado.append(aValor);
                    }
                    else {
                        
                        // en caso contrario se agrega el token y un espacio
                        stbOptimizado.append(aValor);
                        stbOptimizado.append(saltoLn);
                    }
                }
                
                // si es el último agregar el delimitador tal cual.
                else {
                    stbOptimizado.append(aValor);
                }
                
            }
            
            // si hay parentesis, se ignora dicho token
            else if (a.contains("PR")) {
                if (b.equalsIgnoreCase("EXT2")) {
                    stbOptimizado.append(saltoLn);
                }
                stbOptimizado.append(aValor);
                stbOptimizado.append(" ");
            }
            
            // si hay corchetes, se hace un salto de linea
            else if (a.equalsIgnoreCase("SAL1")) {
                stbOptimizado.append(saltoLn);
                stbOptimizado.append(aValor);
            }
            
            // si hay corchetes, se hace un salto de linea
            else if (a.equalsIgnoreCase("SAL2")) {
                stbOptimizado.append(aValor);
                /*if (!b.equalsIgnoreCase("DEL")) {
                    stbTokens.append(saltoLn);
                }*/
                if (b.equalsIgnoreCase("EXT2")) {
                    stbOptimizado.append(saltoLn);
                }
                stbOptimizado.append(saltoLn);
            }
            
            // en caso contrario, se escribe un espacio
            else {
                stbOptimizado.append(aValor);
            }
            
        }
        
        // se guarda el archivo
        guardarArchivo("Optimizado.txt", stbOptimizado.toString());
    }
    
    public void generarIntermedio () {
        
        // Indica el numero de instruccion.
        int numIns = 1;
        
        // Numero de tripleta
        int numTrip = 1;
        
        // Numero de condicion
        int numCon = 1;
        
        // Pila que contiene la posición de llamada del do.
        Stack<Integer> insDo = new Stack<>();
        
        // Se recargan las listas que contendran los tokens.
        ArrayList<String> tokens = this.tokens.getTokenTodo();
        ArrayList<String> valorTokens = this.tokens.getValorTodo();
        
        // Se inician las variables que almacenaran información del código intermedio.
        column1 = new ArrayList<>();
        column2 = new ArrayList<>();
        column3 = new ArrayList<>();
        column4 = new ArrayList<>();
        posDo = new ArrayList<>();
        posWhile = new ArrayList<>();
        
        // Empieza la diversión, se verifica token por token.
        for (int i = 0; i < tokens.size(); i++) {
            
            // Si el token es una palabra reservada, se revisa de cual se trata.
            if(tokens.get(i).contains("PR")) {
                
                // Si hay un do, se guarda el número de instrucción.
                if (valorTokens.get(i).equalsIgnoreCase("do")) {
                    posDo.add(numIns);
                    insDo.push(numIns);
                }
                
                // Si hay un while
                else if (valorTokens.get(i).equalsIgnoreCase("while")) {
                    
                    // Se guarda el inicio del while
                    posWhile.add(numIns);
                    
                    // Se guarda en la tripleta la variable a comprobar
                    column1.add(numIns);
                    column2.add("T" +numTrip);
                    column3.add(valorTokens.get(i+2));
                    column4.add("=");
                    numIns++;
                    
                    // Se analiza con que se debe comparar
                    column1.add(numIns);
                    column2.add("T" +numTrip);
                    column3.add(valorTokens.get(i+4));
                    column4.add(valorTokens.get(i+3));
                    numIns++;
                    
                    // Si es verdadero, debe continuar con la siguiente instruccion.
                    int sigIns = numIns + 2;
                    column1.add(numIns);
                    column2.add("TR" +numCon);
                    column3.add("TRUE");
                    column4.add(insDo.pop()+"");
                    numIns++;
                    
                    // Si es falso, se debe regresar al anterior do
                    column1.add(numIns);
                    column2.add("TR" +numCon);
                    column3.add("FALSE");
                    column4.add(sigIns+"");
                    numIns++;
                    numTrip++;
                    numCon++;
                    
                }
                
                else {
                    continue;
                }
                
            }
            
            // Si el token es un operador de asignación.
            if(tokens.get(i).contains("OAS")) {
                // Se considera si hay un delimitador despúes de su siguiente token
                if (tokens.get(i+2).equalsIgnoreCase("DEL")) {
                    
                    // De ser así estamos ante una asignación simple y la tripleta.
                    column1.add(numIns);
                    column2.add(valorTokens.get(i-1));
                    column3.add(valorTokens.get(i+1));
                    column4.add("=");
                    numIns++;
                }
                
                // En este caso, tenemos una probable operación matemática.
                else {
                    
                    // Variable a la que se asignará el resultado final.
                    String variableAsig = valorTokens.get(i-1);
                    
                    // Se guarda en una lista nueva la operacion.
                    ArrayList<String> valoresTokensOp = new ArrayList<>();
                    
                    // Saltamos el guardado del operador de asignación.
                    i++;
                    
                    while (!tokens.get(i).equalsIgnoreCase("DEL")) {
                        valoresTokensOp.add(valorTokens.get(i));
                        i++;
                    }
                    
                    // Se va recorriendo la lista hasta que no queden variables por comparar
                    while (valoresTokensOp.size() > 1) {
                        
                        // Si hay un parentesis en la operación.
                        if (valoresTokensOp.indexOf(")") != -1) {
                            
                            // Se almacenan las posiciones.
                            int posFin = valoresTokensOp.indexOf(")");
                            int posIni = posFin - 2;
                            
                            // Se revisa que antes dos tokens anteriores no sean "(".
                            if (!valoresTokensOp.get(posIni).equalsIgnoreCase("(")) {
                                
                                // Se busca el inicio de este parentesis
                                for (int n = posFin; n >= 0; n--) {
                                    
                                    // Si se encuentra el parentesis.
                                    if (valoresTokensOp.get(n).equalsIgnoreCase("(")) {
                                        // Se guarda la posicion.
                                        posIni = n;
                                        
                                        // Se termina el ciclo.
                                        break;
                                    }
                                }
                                
                                // Se guarda la operacion que se encuentra dentro del parentesis.
                                ArrayList<String> tokensParentesis = new ArrayList<>();
                                
                                // Se recorre el arreglo hasta que encontremos el final del parentesis.
                                int posReemplazo = posIni + 1;
                                while(!valoresTokensOp.get(posReemplazo+1).equalsIgnoreCase(")")) {
                                    // Se guarda la operacion
                                    tokensParentesis.add(valoresTokensOp.remove(posReemplazo));
                                    // Si es el último
                                    if (valoresTokensOp.get(posReemplazo+1).equalsIgnoreCase(")")) {
                                        tokensParentesis.add(valoresTokensOp.get(posReemplazo));
                                    }
                                }
                                
                                // Se analiza lo que se encuentra adentro del parentesis.
                                while (tokensParentesis.size() > 1) {
                                    
                                    // Si hay una multiplicación en la operación.
                                    if (tokensParentesis.lastIndexOf("*") != -1) {

                                        // Se almacena la penúltima variable en el triplo y se elimina de la lista.
                                        column1.add(numIns);
                                        column2.add("T" +numTrip);
                                        column3.add(tokensParentesis.remove(tokensParentesis.lastIndexOf("*")-1));
                                        column4.add("=");
                                        numIns++;

                                        // En el triplo se almacena la operacion realizada.
                                        column1.add(numIns);
                                        column2.add("T" +numTrip);
                                        column3.add(tokensParentesis.remove(tokensParentesis.lastIndexOf("*")+1));
                                        column4.add(tokensParentesis.get(tokensParentesis.lastIndexOf("*")));
                                        numIns++;

                                        // Se agrega a la lista el triplo realizado.
                                        tokensParentesis.set(tokensParentesis.lastIndexOf("*"),"T" +numTrip);

                                        // Se aumenta el contador del triplo
                                        numTrip++;

                                        continue;
                                    }

                                    // Si hay una division en la operación.
                                    else if (tokensParentesis.lastIndexOf("/") != -1) {

                                        // Se almacena la antepenúltima variable en el triplo y se elimina de la lista.
                                        column1.add(numIns);
                                        column2.add("T" +numTrip);
                                        column3.add(tokensParentesis.remove(tokensParentesis.lastIndexOf("/")-1));
                                        column4.add("=");
                                        numIns++;

                                        // En el triplo se almacena la operacion realizada.
                                        column1.add(numIns);
                                        column2.add("T" +numTrip);
                                        column3.add(tokensParentesis.remove(tokensParentesis.lastIndexOf("/")+1));
                                        column4.add(tokensParentesis.get(tokensParentesis.lastIndexOf("/")));
                                        numIns++;

                                        // Se agrega a la lista el triplo realizado.
                                        tokensParentesis.set(tokensParentesis.lastIndexOf("/"),"T" +numTrip);

                                        // Se aumenta el contador del triplo
                                        numTrip++;

                                        continue;
                                    }

                                    // Si solo quedan sumas y restas.
                                    else {

                                        // Se almacena la antepenúltima variable en el triplo y se elimina de la lista.
                                        column1.add(numIns);
                                        column2.add("T" +numTrip);
                                        column3.add(tokensParentesis.remove(tokensParentesis.size()-3));
                                        column4.add("=");
                                        numIns++;

                                        // En el triplo se almacena la operacion realizada.
                                        column1.add(numIns);
                                        column2.add("T" +numTrip);
                                        column3.add(tokensParentesis.remove(tokensParentesis.size()-1));
                                        column4.add(tokensParentesis.remove(tokensParentesis.size()-1));
                                        numIns++;

                                        // Se agrega a la lista el triplo realizado.
                                        tokensParentesis.add("T" +numTrip);

                                        // Se aumenta el contador del triplo
                                        numTrip++;
                                    }
                                    
                                }
                                
                                // Ahora la variable temporal restante se pasa al valoresTokensOp.
                                valoresTokensOp.set(posReemplazo, tokensParentesis.get(0));
                                
                                // El ciclo analiza la siguiente variable.
                                continue;
                                
                            }
                            
                            // En este caso, la operación no tiene mas operaciones alrededor
                            else {
                                
                                // Primero debemos comprobar que no estemos en el final del lado derecho.
                                if (posFin < valoresTokensOp.size()-1) {
                                    
                                    // Se verifica que haya una suma, resta, multiplicacion, division o parentesis final del lado derecho
                                    if (valoresTokensOp.get(posFin+1).equalsIgnoreCase("+") || valoresTokensOp.get(posFin+1).equalsIgnoreCase("-") || valoresTokensOp.get(posFin+1).equalsIgnoreCase("*") || valoresTokensOp.get(posFin+1).equalsIgnoreCase("/") || valoresTokensOp.get(posFin+1).equalsIgnoreCase(")")) {
                                        
                                        // De ser así, se elimina el parentesis
                                        valoresTokensOp.remove(posFin);
                                    }
                                    
                                    // En cualquier otro caso, se cambia el parentesis por una multiplicación
                                    else {
                                        valoresTokensOp.set(posFin, "*");
                                    }
                                        
                                }
                                
                                // Al ser el final, solamente se elimina el parentesis.
                                else {
                                    valoresTokensOp.remove(posFin);
                                }
                                
                                // Ahora debemos comprobar que no estemos al principio del lado izquierdo.
                                if (posIni > 0) {
                                    // Se verifica que haya una suma, resta, multiplicación, división o parentesis del lado izquierdo.
                                    if (valoresTokensOp.get(posIni-1).equalsIgnoreCase("+") || valoresTokensOp.get(posIni-1).equalsIgnoreCase("-") || valoresTokensOp.get(posIni-1).equalsIgnoreCase("*") || valoresTokensOp.get(posIni-1).equalsIgnoreCase("/") || valoresTokensOp.get(posIni-1).equalsIgnoreCase(")") || valoresTokensOp.get(posIni-1).equalsIgnoreCase("(")) {
                                        
                                        // De ser así, se elimina el parentesis
                                        valoresTokensOp.remove(posIni);
                                    }
                                    
                                    // En cualquier otro caso, se cambia el parentesis por una multiplicación
                                    else {
                                        valoresTokensOp.set(posIni, "*");
                                    }
                                    
                                }
                                
                                // Al ser el principio, solamente se elimina el parentesis.
                                else {
                                    valoresTokensOp.remove(posIni);
                                }
                                
                            }
                            
                            continue;
                        }
                        
                        // Si hay una multiplicación en la operación.
                        else if (valoresTokensOp.lastIndexOf("*") != -1) {
                            
                            // Se almacena la penúltima variable en el triplo y se elimina de la lista.
                            column1.add(numIns);
                            column2.add("T" +numTrip);
                            column3.add(valoresTokensOp.remove(valoresTokensOp.lastIndexOf("*")-1));
                            column4.add("=");
                            numIns++;

                            // En el triplo se almacena la operacion realizada.
                            column1.add(numIns);
                            column2.add("T" +numTrip);
                            column3.add(valoresTokensOp.remove(valoresTokensOp.lastIndexOf("*")+1));
                            column4.add(valoresTokensOp.get(valoresTokensOp.lastIndexOf("*")));
                            numIns++;

                            // Se agrega a la lista el triplo realizado.
                            valoresTokensOp.set(valoresTokensOp.lastIndexOf("*"),"T" +numTrip);
                            
                            // Se aumenta el contador del triplo
                            numTrip++;
                            
                            continue;
                        }
                        
                        // Si hay una division en la operación.
                        else if (valoresTokensOp.lastIndexOf("/") != -1) {
                            
                            // Se almacena la variable anterior en el triplo y se elimina de la lista.
                            column1.add(numIns);
                            column2.add("T" +numTrip);
                            column3.add(valoresTokensOp.remove(valoresTokensOp.lastIndexOf("/")-1));
                            column4.add("=");
                            numIns++;

                            // En el triplo se almacena la operacion realizada.
                            column1.add(numIns);
                            column2.add("T" +numTrip);
                            column3.add(valoresTokensOp.remove(valoresTokensOp.lastIndexOf("/")+1));
                            column4.add(valoresTokensOp.get(valoresTokensOp.lastIndexOf("/")));
                            numIns++;

                            // Se agrega a la lista el triplo realizado.
                            valoresTokensOp.set(valoresTokensOp.lastIndexOf("/"),"T" +numTrip);
                            
                            // Se aumenta el contador del triplo
                            numTrip++;
                            
                            continue;
                        }
                        
                        // Si solo quedan sumas y restas.
                        else {
                            
                            // Se almacena la antepenúltima variable en el triplo y se elimina de la lista.
                            column1.add(numIns);
                            column2.add("T" +numTrip);
                            column3.add(valoresTokensOp.remove(valoresTokensOp.size()-3));
                            column4.add("=");
                            numIns++;

                            // En el triplo se almacena la operacion realizada.
                            column1.add(numIns);
                            column2.add("T" +numTrip);
                            column3.add(valoresTokensOp.remove(valoresTokensOp.size()-1));
                            column4.add(valoresTokensOp.remove(valoresTokensOp.size()-1));
                            numIns++;

                            // Se agrega a la lista el triplo realizado.
                            valoresTokensOp.add("T" +numTrip);
                            
                            // Se aumenta el contador del triplo
                            numTrip++;
                        }
                    }
                    
                    // El resultado final es almacenado en la variable
                    column1.add(numIns);
                    column2.add(variableAsig);
                    column3.add(valoresTokensOp.get(0));
                    column4.add("=");
                    numIns++;
                    
                }
            }
        }
        
        // Ahora se genera el texto de la tripleta.
        StringBuilder texto = new StringBuilder("\tDO\tDF\tO");
        
        texto.append(saltoLn);
        for (int i = 0; i < column1.size(); i++) {
            texto.append(column1.get(i)).append("\t")
                    .append(column2.get(i)).append("\t")
                    .append(column3.get(i)).append("\t")
                    .append(column4.get(i)).append(saltoLn);
        }
        
        // Se guarda el archivo.
        guardarArchivo("Intermedio.txt", texto.toString());
    }
    
    public void generarObjeto() {
        
        // Se crean variables referentes a los registros.
        String AH = "";
        String AL = "";
        String BH = "";
        String BL = "";
        String CL = "";
        
        // Variables con el numero de ciclo y condicion.
        int numCiclo = 1;
        int numCon = 1;
        int numEt = 1;
        
        // Se guarda la posición del primer do y while.
        int insDo = 0;
        int insWhile = 0;
        try {
            insDo = posDo.remove(0) - 1;
            insWhile = posWhile.remove(0) - 1;
        }
        catch (IndexOutOfBoundsException ex) {
            // No hay ciclos.
            insDo = -1;
            insWhile = -1;
        }
        
        // Pila que almacena siempre el ultimo ciclo.
        Stack<Integer> ultCiclo = new Stack<>();
        
        // En dado caso de que la pila se vacíe antes, se usa este String.
        String ultCiclo2 = "";
        
        // Variable que contendrá el código ensamblador
        StringBuilder texto = new StringBuilder();
        
        // Lo divertido del ensamblador comienza en esta parte.
        for (int i = 0; i < column1.size(); i++) {
            
            // Se verifica si estamos ante una instruccion do.
            if (i == insDo) {
                
                ultCiclo2 = "ET" + numEt;
                texto.append(saltoLn).append(ultCiclo2).append(":").append(saltoLn);
                ultCiclo.push(numEt);
                numEt++;
                
                // Se elimina la posicion de este do.
                try {
                    while (insDo == posDo.get(0) - 1) {
                        insDo = posDo.remove(0) - 1;
                    }
                    insDo = posDo.remove(0) - 1;
                }
                catch (IndexOutOfBoundsException ex) {
                    // No hay más ciclos.
                    insDo = -1;
                }
            }
            
            // Si estamos ante una instruccion while.
            if (i == insWhile) {
                
                texto.append(saltoLn).append("ET").append(numEt).append(":").append(saltoLn);
                numEt++;
                
                /*
                // Se limpia lo que habia en AL.
                if (!AL.isEmpty()) {
                    texto.append("\tMOV AL, 0;").append(saltoLn);
                    AL = "";
                }
                */
                
                // Se pasa la variable a comparar a AL.
                texto.append("\tMOV AL, ").append(column3.get(i)).append(";").append(saltoLn);
                AL = column3.get(i);
                i++;
                
                // Ahora se compara lo que tiene AL.
                texto.append("\tCMP AL, ").append(column3.get(i)).append(";").append(saltoLn);
                AL = column3.get(i);
                
                // Se procede a leer que comparación se esta realizando.
                // Si se trata de un menor.
                if (column4.get(i).equalsIgnoreCase("<")) {
                    try {
                        ultCiclo.lastElement();
                        texto.append("\tJL ET").append(ultCiclo.pop()).append(";").append(saltoLn);
                    }
                    catch (EmptyStackException | NoSuchElementException ex) {
                        texto.append("\tJL ").append(ultCiclo2).append(";").append(saltoLn);
                        ultCiclo2 = "";
                    }
                    
                }
                
                // Si se trata de un menor o igual que.
                else if (column4.get(i).equalsIgnoreCase("<=")) {
                    try {
                        ultCiclo.lastElement();
                        texto.append("\tJLE ET").append(ultCiclo.pop()).append(";").append(saltoLn);
                    }
                    catch (EmptyStackException | NoSuchElementException ex) {
                        texto.append("\tJLE ").append(ultCiclo2).append(";").append(saltoLn);
                        ultCiclo2 = "";
                    }
                }
                
                // Si se trata de un mayor.
                else if (column4.get(i).equalsIgnoreCase(">")) {
                    try {
                        ultCiclo.lastElement();
                        texto.append("\tJG ET").append(ultCiclo.pop()).append(";").append(saltoLn);
                    }
                    catch (EmptyStackException | NoSuchElementException ex) {
                        texto.append("\tJG ").append(ultCiclo2).append(";").append(saltoLn);
                        ultCiclo2 = "";
                    }
                }
                
                // Si se trata de un mayor o igual que.
                else if (column4.get(i).equalsIgnoreCase(">=")) {
                    try {
                        ultCiclo.lastElement();
                        texto.append("\tJGE ET").append(ultCiclo.pop()).append(";").append(saltoLn);
                    }
                    catch (EmptyStackException | NoSuchElementException ex) {
                        texto.append("\tJGE ").append(ultCiclo2).append(";").append(saltoLn);
                        ultCiclo2 = "";
                    }
                }
                
                // Si se trata de un igual que.
                else if (column4.get(i).equalsIgnoreCase("==")) {
                    try {
                        ultCiclo.lastElement();
                        texto.append("\tJE ET").append(ultCiclo.pop()).append(";").append(saltoLn);
                    }
                    catch (EmptyStackException | NoSuchElementException ex) {
                        texto.append("\tJE ").append(ultCiclo2).append(";").append(saltoLn);
                        ultCiclo2 = "";
                    }
                }
                
                // Si se trata de un diferente de.
                else if (column4.get(i).equalsIgnoreCase("!=")) {
                    try {
                        ultCiclo.lastElement();
                        texto.append("\tJNE ET").append(ultCiclo.pop()).append(";").append(saltoLn);
                    }
                    catch (EmptyStackException | NoSuchElementException ex) {
                        texto.append("\tJNE ").append(ultCiclo2).append(";").append(saltoLn);
                        ultCiclo2 = "";
                    }
                }
                
                // Se saltan las dos saltoLns que contienen la instrucción while
                i = i + 2;
                
                // Se elimina la posicion de este while.
                try {
                    insWhile = posWhile.remove(0) - 1;
                }
                catch (IndexOutOfBoundsException ex) {
                    // No hay más ciclos.
                    insWhile = -1;
                }
                
                // Si a continuación no nos encontramos con un while o un do,
                // se considera que es continuación del ciclo anterior.
                if (i + 1 != insDo && i + 1 != insWhile && i + 1 < column1.size()) {
                    if (!ultCiclo2.isEmpty()) {
                        texto.append("\tJMP ").append(ultCiclo2).append("P2").append(";").append(saltoLn)
                                .append(saltoLn)
                                .append(ultCiclo2).append("P2").append(":").append(saltoLn);
                    }
                    else {
                        texto.append("\tJMP END;").append(saltoLn)
                                .append(saltoLn)
                                .append("END:").append(saltoLn);
                    }
                }
            }
            
            // Se verifica que el operador es una asignación.
            else if (!column2.get(i).contains("T") && !column3.get(i).contains("T")) {
                
                texto.append("\tMOV ").append(column2.get(i)).append(", ").append(column3.get(i)).append(";").append(saltoLn);
                
            }
            
            // Si solamente la columna 2 no contiene una variable temporal, estamos ante una asignación.
            else if (!column2.get(i).contains("T")) {
                
                // Se mueve de BL el resultado a la variable correspondiente.
                texto.append("\tMOV ").append(column2.get(i)).append(", BL;").append(saltoLn);
                
                // Se limpia la variable para detectar que lo que almacena BH ya no es importante.
                BL = "";
                
            }
            
            // De no ser ningun caso anterior, estamos ante una operación aritmetica.
            else {
                
                // Si BL se encuentra vacía, se procede a realizar la operación.
                if (BL.isEmpty()) {
                    
                    // Se mueve a BL el primer número.
                    texto.append("\tMOV BL, ").append(column3.get(i)).append(";").append(saltoLn);
                    BL = column3.get(i);
                    
                    // Se mueve al siguiente número.
                    i++;
                    
                    // Si no estamos ante una división, se utiliza el registro BH
                    if (!column4.get(i).equalsIgnoreCase("/")) {
                        texto.append("\tMOV BH, ").append(column3.get(i)).append(";").append(saltoLn);
                        BH = column3.get(i);
                    }
                    
                    // Pero si se trata de una división.
                    else {
                        
                        // Se limpia la parte alta de AX si no se encuentra vacía.
                        if (!AH.isEmpty()) {
                            texto.append("\tMOV AH, 0;").append(saltoLn);
                            AH = "";
                        }
                        
                        // Se pasa a AL el número a dividir.
                        texto.append("\tMOV AL, BL;").append(saltoLn);
                        
                        // Se pasa a CL el divisor.
                        texto.append("\tMOV CL, ").append(column3.get(i)).append(";").append(saltoLn);
                        CL = column3.get(i);
                        
                        // Se realiza la división y se indica los registros con información.
                        texto.append("\tDIV CL;").append(saltoLn);
                        AH = "Residuo";
                        AL = "Resultado";
                        
                        // Se guarda el resultado en BL.
                        texto.append("\tMOV BL, AL;").append(saltoLn);
                        BL = CL;
                    }
                    
                    // Si se trata de una multiplicación.
                    if (column4.get(i).equalsIgnoreCase("*")) {
                        texto.append("\tMUL BL, BH;").append(saltoLn);
                        BL = "BL * BH";
                    }
                    
                    // Si se trata de una resta.
                    else if (column4.get(i).equalsIgnoreCase("-")) {
                        texto.append("\tSUB BL, BH;").append(saltoLn);
                        BL = "BL - BH";
                    }
                    
                    // Si se trata de una suma.
                    else if (column4.get(i).equalsIgnoreCase("+")) {
                        texto.append("\tADD BL, BH;").append(saltoLn);
                        BL = "BL + BH";
                    }
                }
                
                // Si BL tiene guardada información, se utiliza la misma para seguir utilizandose.
                else {
                    
                    // Si no estamos ante una división, se utiliza el registro BH
                    if (!column4.get(i+1).equalsIgnoreCase("/")) {
                        texto.append("\tMOV BH, ").append(column3.get(i)).append(";").append(saltoLn);
                        BH = column3.get(i);
                    }
                    
                    // Pero si se trata de una división.
                    else {
                        
                        // Se limpia la parte alta de AX si no se encuentra vacía.
                        if (!AH.isEmpty()) {
                            texto.append("\tMOV AH, 0;").append(saltoLn);
                            AH = "";
                        }
                        
                        // Se pasa a AL el número a dividir.
                        texto.append("\tMOV AL, ").append(column3.get(i)).append(";").append(saltoLn);
                        
                        // Se pasa a CL el divisor.
                        texto.append("\tMOV CL, BL;").append(saltoLn);
                        CL = BL;
                        
                        // Se realiza la división y se indica los registros con información.
                        texto.append("\tDIV CL;").append(saltoLn);
                        AH = "Residuo";
                        AL = "Resultado";
                        
                        // Se guarda el resultado en BL.
                        texto.append("\tMOV BL, AL;").append(saltoLn);
                        BL = AL;
                        
                        // Se salta la instrucción que hace un guardado de dos temporales.
                        i++;
                    }
                    
                    // Se salta la instrucción que hace un guardado de dos temporales.
                    i++;
                    
                    // Si se trata de una multiplicación.
                    if (column4.get(i).equalsIgnoreCase("*")) {
                        texto.append("\tMUL BL, BH;").append(saltoLn);
                        BL = "BL * BH";
                    }
                    
                    // Si se trata de una resta.
                    else if (column4.get(i).equalsIgnoreCase("-")) {
                        texto.append("\tSUB BL, BH;").append(saltoLn);
                        BL = "BL - BH";
                    }
                    
                    // Si se trata de una suma.
                    else if (column4.get(i).equalsIgnoreCase("+")) {
                        texto.append("\tADD BL, BH;").append(saltoLn);
                        BL = "BL + BH";
                    }
                    
                }
                
            }
            
            // Si la siguiente instrucción es un ciclo.
            if (i + 1 == insDo || i + 1 == insWhile) {
                
                // Se escribe un salto hacia el ciclo.
                texto.append("\tJMP ET").append(numEt).append(";").append(saltoLn);
                
            }
            
            // Si estamos en la ultima linea.
            if (i + 1 == column1.size()) {
                texto.append("\tEXIT;");
            }
            
        }
        
        // Se guarda el archivo final.
        guardarArchivo("Objeto.txt", texto.toString());
    }
    
    public void guardarArchivo(String archivoExtension, String texto) {
        
        try {
            FileWriter fw = new FileWriter(archivoExtension);
            fw.write(texto);
            fw.close();
            JOptionPane.showConfirmDialog(null, "El archivo ''" +archivoExtension+ "'' ha sido guardado con éxito.", "Archivo guardado con éxito", JOptionPane.DEFAULT_OPTION, JOptionPane.INFORMATION_MESSAGE);
        }
        catch (IOException ex) {
            
        }
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(AritmeticasTokens.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(AritmeticasTokens.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(AritmeticasTokens.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(AritmeticasTokens.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new AritmeticasTokens().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JScrollPane jScrollPane5;
    private javax.swing.JScrollPane jScrollPane6;
    private javax.swing.JScrollPane jScrollPane7;
    private javax.swing.JTable jTable1;
    private javax.swing.JTable jTable2;
    private javax.swing.JTable jTable3;
    private javax.swing.JTable jTable4;
    private javax.swing.JTable jTable5;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JTextArea jTextArea2;
    // End of variables declaration//GEN-END:variables
}
