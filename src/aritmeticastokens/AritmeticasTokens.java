package aritmeticastokens;

// librerias
import java.util.ArrayList;
import java.util.StringTokenizer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.swing.JOptionPane;
import javax.swing.table.DefaultTableModel;

public class AritmeticasTokens extends javax.swing.JFrame {
    
    // declaracion de variables
    Token tokens = new Token();
    ArrayList<String> tipo = new ArrayList<>();
    ArrayList<String> tipotoken = new ArrayList<>();
    ArrayList<String> errores = new ArrayList<>();
    DefaultTableModel dtmPalabras = new DefaultTableModel();
    DefaultTableModel dtmSimbolos = new DefaultTableModel();
    DefaultTableModel dtmOperadores = new DefaultTableModel();
    DefaultTableModel dtmConstantes = new DefaultTableModel();
    DefaultTableModel dtmErrores = new DefaultTableModel();
    StringBuilder stbTokens = new StringBuilder();
    StringBuilder stbCodigo = new StringBuilder();

    // constructor de la ventana
    public AritmeticasTokens() {
        initComponents();
        
        // iniciar tablas
        tablas();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jButton1 = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jScrollPane2 = new javax.swing.JScrollPane();
        jTable1 = new javax.swing.JTable();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jScrollPane3 = new javax.swing.JScrollPane();
        jTable2 = new javax.swing.JTable();
        jLabel4 = new javax.swing.JLabel();
        jScrollPane4 = new javax.swing.JScrollPane();
        jTable3 = new javax.swing.JTable();
        jLabel5 = new javax.swing.JLabel();
        jScrollPane5 = new javax.swing.JScrollPane();
        jTable4 = new javax.swing.JTable();
        jLabel6 = new javax.swing.JLabel();
        jScrollPane6 = new javax.swing.JScrollPane();
        jTextArea2 = new javax.swing.JTextArea();
        jScrollPane7 = new javax.swing.JScrollPane();
        jTable5 = new javax.swing.JTable();
        jLabel7 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jButton1.setText("Analizar");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jLabel1.setText("Código");

        jTextArea1.setColumns(20);
        jTextArea1.setRows(5);
        jScrollPane1.setViewportView(jTextArea1);

        jTable1.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        jScrollPane2.setViewportView(jTable1);

        jLabel2.setText("Tabla de simbolos");

        jLabel3.setText("Tabla de Operadores Aritmeticos");

        jTable2.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        jScrollPane3.setViewportView(jTable2);

        jLabel4.setText("Tabla de Constantes");

        jTable3.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        jScrollPane4.setViewportView(jTable3);

        jLabel5.setText("Tabla de errores");

        jTable4.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        jScrollPane5.setViewportView(jTable4);

        jLabel6.setText("Tokens");

        jTextArea2.setColumns(20);
        jTextArea2.setRows(5);
        jScrollPane6.setViewportView(jTextArea2);

        jTable5.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        jScrollPane7.setViewportView(jTable5);

        jLabel7.setText("Tabla de palabras reservadas");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 271, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane6, javax.swing.GroupLayout.PREFERRED_SIZE, 270, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jScrollPane7, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
                            .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
                            .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE))
                        .addContainerGap())
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 99, Short.MAX_VALUE)
                        .addComponent(jLabel3)
                        .addGap(96, 96, 96))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(127, 127, 127)
                                .addComponent(jLabel4))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(131, 131, 131)
                                .addComponent(jLabel2)))
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
            .addGroup(layout.createSequentialGroup()
                .addGap(122, 122, 122)
                .addComponent(jLabel1)
                .addGap(251, 251, 251)
                .addComponent(jLabel6)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jLabel7)
                .addGap(114, 114, 114))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jButton1)
                .addContainerGap())
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jScrollPane4))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jScrollPane5)))
                .addContainerGap())
            .addGroup(layout.createSequentialGroup()
                .addGap(412, 412, 412)
                .addComponent(jLabel5)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 16, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel6)
                    .addComponent(jLabel7))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 380, Short.MAX_VALUE)
                    .addComponent(jScrollPane6)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane7, javax.swing.GroupLayout.PREFERRED_SIZE, 101, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel3)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jLabel4)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jLabel5)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane5, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jButton1)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        // TODO add your handling code here:
        
        // nuevo objeto de tipo token
        tokens = new Token();
        
        // auxiliares para la limpieza de las tablas
        int c = dtmSimbolos.getRowCount();
        int d = dtmOperadores.getRowCount();
        int e = dtmConstantes.getRowCount();
        int f = dtmErrores.getRowCount();
        int p = dtmPalabras.getRowCount();
        
        // se elimina la info de las tablas
        for (int i = 0; i < c; i++) {
            dtmSimbolos.removeRow(0);  
        }
        
        for (int i = 0; i < d; i++) {
            dtmOperadores.removeRow(0);  
        }
        
        for (int i = 0; i < e; i++) {
            dtmConstantes.removeRow(0);  
        }
        
        for (int i = 0; i < f; i++) {
            dtmErrores.removeRow(0);  
        }
        
        for (int i = 0; i < p; i++) {
            dtmPalabras.removeRow(0);  
        }
        
        // stringbuilder para traspasar el codigo a tokens
        stbTokens = new StringBuilder();
        
        // se analizan los tokens
        busquedaTokens(jTextArea1.getText());
        
        // en stbtokens se empieza a escribir los tokens que se mostrarán en pantalla
        for (int i = 0; i < tokens.getTokenTodo().size(); i++) {
            String a = (tokens.getTokenTodo().get(i));
            String b = a;
            
            if (i > 0) {
                b = (tokens.getTokenTodo().get(i-1));
            }
            
            
            // si hay un delimitador, se hace un salto de linea
            if (a.equalsIgnoreCase("DEL")) {
                stbTokens.append(a);
                stbTokens.append("\n");
            }
            
            // si hay parentesis, se ignora dicho token
            else if (a.equalsIgnoreCase("EXT1")) {
            }
            
            // si hay parentesis, se ignora dicho token
            else if (a.equalsIgnoreCase("EXT2")) {
            }
            
            // si hay parentesis, se ignora dicho token
            else if (a.contains("PR")) {
                if (b.equalsIgnoreCase("EXT2")) {
                    stbTokens.append("\n");
                }
                stbTokens.append(a);
                stbTokens.append(" ");
            }
            
            // si hay corchetes, se hace un salto de linea
            else if (a.equalsIgnoreCase("SAL1")) {
                stbTokens.append("\n");
            }
            
            // si hay corchetes, se hace un salto de linea
            else if (a.equalsIgnoreCase("SAL2")) {
                /*if (!b.equalsIgnoreCase("DEL")) {
                    stbTokens.append("\n");
                }*/
                if (b.equalsIgnoreCase("EXT2")) {
                    stbTokens.append("\n");
                }
                stbTokens.append("\n");
            }
            
            // en caso contrario, se escribe un espacio
            else {
                stbTokens.append(a);
                stbTokens.append(" ");
            }

        }
        
        // si hay codigo escrito, se analiza en busca de errores faltantes y no de identificadores.
        if (!jTextArea1.getText().equals("")) {
            
            // se guarda el codigo de tokens en un auxiliar
            String codigoTokens = stbTokens.toString();
            String codigo = jTextArea1.getText();
            StringBuilder stbCodigo = new StringBuilder();
            
            String[] lineaCodigoTokens;
            String[] lineaCodigo;
            
            /*// se elimina el corchete terminal del código
            if (codigo.contains("}")) {
                StringBuilder stbCodigo = new StringBuilder();
                lineaCodigo = codigo.split("}");
                for(String cod : lineaCodigo) {
                    stbCodigo.append(cod);
                    stbCodigo.deleteCharAt(stbCodigo.length()-1);
                }
                codigo = stbCodigo.toString();
            }*/
            
            // se divide por lineas
            lineaCodigoTokens = codigoTokens.split("\\n");
            lineaCodigo = codigo.split("\\n");
            
            if (lineaCodigo.length == 1) {
                lineaCodigo = codigo.split(";");
                for (int i = 0; i < lineaCodigo.length; i++) {
                    StringBuilder stbLineaCodigo;
                    stbLineaCodigo = new StringBuilder(lineaCodigo[i] + ";");
                    lineaCodigo[i] = stbLineaCodigo.toString();
                }
                System.out.println(lineaCodigo.length);
                System.out.println(lineaCodigoTokens.length);
            }
            
            int numLinea = 0;
            
            try {
                
                // se recorre cada linea
                for (int i = 0; i < lineaCodigoTokens.length; i++) {
                    
                    // apuntador auxiliar y base que servirá para buscar el IDE
                    int apunIDE = -1;
                    int apunBase = -1;
                    
                    // el tipo que tiene el identificador auxiliar y base de la operacion
                    String tipoIDE = "null";
                    String tipoBase = "null";
                    String tipoPR = "null";
                    Boolean While = false;
                    
                    // numLinea tiene el numero de linea que estamos trabajando
                    numLinea = i + 1;
                    
                    // el codigo esta dividido por espacios, se separan los tokens
                    String[] tempTokens = lineaCodigoTokens[i].split("\\s");
                    String[] tempCodigo = lineaCodigo[i].split("\\s");
                    String[] codigoSinEspacios = tempCodigo;
                    
                    
                    if(tempCodigo.length == 1) {
                        stbCodigo.append(tempCodigo[0]);
                        continue;
                    }
                    
                    // del codigo eliminamos el DEL
                    if (tempTokens.length > 1) {
                        tempCodigo = delDeArr(tempCodigo, tempCodigo.length - 1);
                    }
                    
                    // se verifica si la primera palabra es una palabra reservada
                    if (tempTokens[0].contains("PR")) {
                        
                        String PR = tokens.getValorPR().get(tokens.buscarPR(tempTokens[0]));
                        
                        // primero buscaremos si la primera palabra es una instruccion do
                        if (PR.equalsIgnoreCase("do")) {
                            stbCodigo.append(codigoSinEspacios[0]).append(codigoSinEspacios[1]).append("\n");
                            continue;
                        }
                        
                        if (!PR.equalsIgnoreCase("while")) {
                            tipoPR = PR;

                            if (tempTokens.length > 1) {
                                if (tempCodigo[1].equalsIgnoreCase("(")) {
                                    stbCodigo.append(tempCodigo[0]);
                                }
                                else {
                                    stbCodigo.append(tempCodigo[0] + " ");
                                }
                                tempTokens = delDeArr(tempTokens, 0);
                                tempCodigo = delDeArr(tempCodigo, 0);
                                codigoSinEspacios = delDeArr(codigoSinEspacios, 0);

                                // se verifica que si a continucación hay un IDE, si no se despliega un error y se termina la verificación de línea.
                                if(!tempTokens[0].contains("IDE")) {
                                    String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: falta identificador inicial.";
                                    tokens.setELX(valor);
                                    continue;
                                }
                            }
                        }
                        else {
                            if (tempTokens.length > 1) {
                                if (tempCodigo[1].equalsIgnoreCase("(")) {
                                    stbCodigo.append(tempCodigo[0]);
                                }
                                else {
                                    stbCodigo.append(tempCodigo[0] + " ");
                                }
                                tempTokens = delDeArr(tempTokens, 0);
                                tempCodigo = delDeArr(tempCodigo, 0);
                                codigoSinEspacios = delDeArr(codigoSinEspacios, 0);
                            }
                            While = true;
                        }
                        
                    }
                    
                    
                    
                    // se agrega el código
                    for (int z = 0; z < codigoSinEspacios.length; z++) {
                        stbCodigo.append(codigoSinEspacios[z]);
                        
                        // si es el ultimo caracter
                        if (z == tempCodigo.length) {
                            stbCodigo.append("\n");
                        }
                    }
                    
                    // si el primer token no es un identificador o un error de identificador, se considera un error adicional
                    if (!tempTokens[0].contains("IDE") && !tempTokens[0].contains("ELX") && !tempTokens[0].contains("PR")) {
                        String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: falta identificador inicial.";
                        tokens.setELX(valor);
                    }
                    
                    // en caso contrario se procede a eliminar dicho token
                    else {
                        if (tempTokens.length > 1) {
                            // apuntador auxiliar que servirá para buscar el IDE
                            apunBase = tokens.buscarIDE(tempTokens[0]);
                            tempTokens = delDeArr(tempTokens, 0);
                            tempCodigo = delDeArr(tempCodigo, 0);
                        }
                    }
                    
                    // si el identificador inicial no esta declarado
                    if (tokens.getTokenIDE().get(apunBase)[0].equals("null")) {
                        String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: identificador no declarado.";
                        tokens.setEST(valor);
                    }
                    
                    // en caso contrario, almacenar que tipo es
                    else {
                        tipoBase = tokens.getTokenIDE().get(apunBase)[0];
                        
                        // verificamos que no se haya declarado anteriormente
                        if (!tipoPR.equals("null") && !tipoBase.equals(tipoPR)) {
                            String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: declaración duplicada.";
                            tokens.setELX(valor);
                        }
                    }
                    
                    // si el token no es un operador de asignacion o un error de identificador, se considera un errora adicional
                    if (!tempTokens[0].contains("OAS") && !tempTokens[0].contains("OR") && !tempTokens[0].contains("OB") && !tempTokens[0].contains("ELX") && !tempTokens[0].contains("DEL")) {
                        // pero si es un delimitador, se termina la revisión de la línea.
                        String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: falta operador de asignación.";
                        tokens.setELX(valor);
                    }
                    
                    // en caso contrario se procede a eliminar dicho token
                    else {
                        if (tempTokens.length > 1) {
                            tempTokens = delDeArr(tempTokens, 0);
                            tempCodigo = delDeArr(tempCodigo, 0);
                        }
                    }
                    
                    // si anteriormente no nos encontramos con un DEL, entonces podemos seguir con la verificacion
                    if (tempTokens.length > 1) {
                        // si el token no es un identificador, una constante númerica, una constante flotante o un error de identificador, se considera un error adicional
                        if (!tempTokens[0].contains("IDE") && !tempTokens[0].contains("CE") && !tempTokens[0].contains("CF") && !tempTokens[0].contains("ELX")) {
                            String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: falta operando 1.";
                            tokens.setELX(valor);
                        }

                        // en caso contrario se procede a verificar el semántico
                        else {
                            // antes se debe verificar
                            // en caso de ser entero la base
                            if (tipoBase.equals("int")) {
                                if (!tempTokens[0].contains("IDE")) {
                                    if (!tempTokens[0].contains("CE")) {
                                        String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: incompatibilidad de tipos.";
                                        tokens.setEST(valor);
                                    }
                                    else {
                                        if (tempTokens[1].contains("DEL") && !tipoBase.equals("null")) {
                                            tokens.actualizarIDE(apunBase, tempCodigo[0]);
                                        }
                                    }
                                }
                                else {
                                    apunIDE = tokens.buscarIDE(tempTokens[0]);
                                    tipoIDE = tokens.getTokenIDE().get(apunIDE)[0];
                                    if (tipoIDE.equals("null")) {
                                        String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: identificador no declarado.";
                                        tokens.setEST(valor);
                                    }
                                    else {
                                        if (tokens.getValorIDE().get(apunIDE)[0].equals("null")) {
                                            String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: identificador no inicializado.";
                                            tokens.setEST(valor);
                                        }
                                        else {
                                            if (!tipoIDE.equals("int")) {
                                                String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: incompatibilidad de tipos.";
                                                tokens.setEST(valor);
                                            }
                                        }
                                    }
                                }
                            }
                            // en caso de no ser entero
                            else {
                                if (tempTokens[0].contains("IDE")) {
                                    apunIDE = tokens.buscarIDE(tempTokens[0]);
                                    tipoIDE = tokens.getValorIDE().get(apunIDE)[0];
                                    if (tipoIDE.equals("null")) {
                                        String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: identificador no inicializado.";
                                        tokens.setEST(valor);
                                    }
                                    else {
                                        if (tempTokens[1].contains("DEL") && !tipoBase.equals("null")) {
                                            tokens.actualizarIDE(apunBase, tempCodigo[0]);
                                        }
                                    }
                                }
                                else {
                                    if (tempTokens[1].contains("DEL") && !tipoBase.equals("null")) {
                                        tokens.actualizarIDE(apunBase, tempCodigo[0]);
                                    }
                                }
                            }
                            
                            // se elimina dicho token
                            if (tempTokens.length > 1) {
                                tempTokens = delDeArr(tempTokens, 0);
                            }
                        }
                        
                        // de nuevo, si no ha habido un DEL anteriormente, se continúa la verificación.
                        if (tempTokens.length > 1) {
                            
                            // si el token no es un operador aritmetico o un error de identificador, se considera un errora adicional
                            if (!tempTokens[0].contains("OA") && !tempTokens[0].contains("OR") && !tempTokens[0].contains("OB") && !tempTokens[0].contains("ELX")) {
                                String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: falta operador aritmético.";
                                tokens.setELX(valor);
                            }

                            // en caso contrario se procede a eliminar dicho token
                            else {
                                if (tempTokens.length > 1) {
                                    tempTokens = delDeArr(tempTokens, 0);
                                }
                            }

                            // ahora para el resto de la instrucción se realiza un nuevo ciclo

                            // en esta variable se guardará el numero de operando
                            int g = 2;

                            // se obtiene el número actual de los tokens restantes
                            int k = tempTokens.length;

                            // se recorren los tokens restantes
                            for (int h = 0; h < k; h++) {
                                // si el token no es un identificador, una constante númerica, una constante flotante o un error de identificador, se considera un error adicional
                                if (!tempTokens[0].contains("IDE") && !tempTokens[0].contains("CE") && !tempTokens[0].contains("CF") && !tempTokens[0].contains("ELX")) {
                                    String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: falta operando " +g+ ".";
                                    tokens.setELX(valor);
                                    g++;
                                }
                                
                                // en caso contrario se procede a verificar el semántico
                                else {
                                    // antes se debe verificar
                                    // en caso de ser entero la base
                                    if (tipoBase.equals("int")) {
                                        if (!tempTokens[0].contains("IDE")) {
                                            if (!tempTokens[0].contains("CE")) {
                                                String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: incompatibilidad de tipos.";
                                                tokens.setEST(valor);
                                            }
                                            else {
                                                if (tempTokens[1].contains("DEL") && !tipoBase.equals("null")) {
                                                    tokens.actualizarIDE(apunBase, arregloACodigo(tempCodigo));
                                                }
                                            }
                                        }
                                        else {
                                            apunIDE = tokens.buscarIDE(tempTokens[0]);
                                            tipoIDE = tokens.getTokenIDE().get(apunIDE)[0];
                                            if (tipoIDE.equals("null")) {
                                                String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: identificador no declarado.";
                                                tokens.setEST(valor);
                                            }
                                            else {
                                                if (tokens.getValorIDE().get(apunIDE)[0].equals("null")) {
                                                    String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: identificador no inicializado.";
                                                    tokens.setEST(valor);
                                                }
                                                else {
                                                    if (!tipoIDE.equals("int")) {
                                                        String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: incompatibilidad de tipos.";
                                                        tokens.setEST(valor);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    // en caso de no ser entero
                                    else {
                                        if (tempTokens[0].contains("IDE")) {
                                            apunIDE = tokens.buscarIDE(tempTokens[0]);
                                            tipoIDE = tokens.getValorIDE().get(apunIDE)[0];
                                            if (tipoIDE.equals("null")) {
                                                String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: identificador no inicializado.";
                                                tokens.setEST(valor);
                                            }
                                            else {
                                                if (tempTokens[1].contains("DEL") && !tipoBase.equals("null")) {
                                                    tokens.actualizarIDE(apunBase, arregloACodigo(tempCodigo));
                                                }
                                            }
                                        }
                                        else {
                                            if (tempTokens[1].contains("DEL") && !tipoBase.equals("null")) {
                                                tokens.actualizarIDE(apunBase, arregloACodigo(tempCodigo));
                                            }
                                        }
                                    }

                                    // se elimina dicho token
                                    if (tempTokens.length > 1) {
                                        tempTokens = delDeArr(tempTokens, 0);
                                        g++;
                                    }
                                }

                                // se cambia al siguiente token
                                h++;

                                // si el token no es un operador aritmetico, un delimitador o un error de identificador, se considera un errora adicional
                                if (!tempTokens[0].contains("OA") && !tempTokens[0].contains("DEL") && !tempTokens[0].contains("ELX")) {
                                    String valor = "Línea " +numLinea+ ": La instrucción aritmética está incorrecta: falta operador aritmético o delimitador.";
                                    tokens.setELX(valor);
                                }

                                // en caso contrario se procede a eliminar dicho token
                                else {
                                    if (tempTokens.length > 1) {
                                        tempTokens = delDeArr(tempTokens, 0);
                                    }
                                }
                            }
                            
                        }
                        
                    }
                         
                }
            }
            
            catch (ArrayIndexOutOfBoundsException ex) {
                System.out.println("Índice del arreglo inalcanzable en la línea " + numLinea + " : " +ex.getMessage());
            }
            
            // impresion del codigo optimizado
            imprimirTexto("Código optimizado", codigo.replace(" ", ""));
            
            // imprimir texto
            imprimirTexto("Código optimizado", stbCodigo.toString());
        }
        
        // se llena la tabla de simbolos
        for (int i = 0; i < tokens.getTokenIDE().size(); i++) {
            dtmSimbolos.addRow(new Object[]{tokens.getTokenIDE().get(i)[0],tokens.getValorIDE().get(i)[1],tokens.getTokenIDE().get(i)[1],tokens.getValorIDE().get(i)[0]});
        }
        
        // se llena la tabla de operadores
        for (int i = 0; i < tokens.getTokenOA().size(); i++) {
            dtmOperadores.addRow(new Object[]{tokens.getValorOA().get(i),tokens.getTokenOA().get(i)});
        }
        
        // se llena la tabla de operadores
        for (int i = 0; i < tokens.getTokenOR().size(); i++) {
            dtmOperadores.addRow(new Object[]{tokens.getValorOR().get(i),tokens.getTokenOR().get(i)});
        }
        
        // se llena la tabla de operadores
        for (int i = 0; i < tokens.getTokenOB().size(); i++) {
            dtmOperadores.addRow(new Object[]{tokens.getValorOB().get(i),tokens.getTokenOB().get(i)});
        }
        
        // se llena la tabla de constantes con los constantes enteros
        for (int i = 0; i < tokens.getTokenCE().size(); i++) {
            dtmConstantes.addRow(new Object[]{tokens.getValorCE().get(i),tokens.getTokenCE().get(i)});
        }
        
        // se llena la tabla de constantes con los constantes flotantes
        for (int i = 0; i < tokens.getTokenCF().size(); i++) {
            dtmConstantes.addRow(new Object[]{tokens.getValorCF().get(i),tokens.getTokenCF().get(i)});
        }
        
        // se llena la tabla de errores
        for (int i = 0; i < tokens.getTokenELX().size(); i++) {
            dtmErrores.addRow(new Object[]{tokens.getTokenELX().get(i),tokens.getValorELX().get(i)});
        }
        for (int i = 0; i < tokens.getTokenEST().size(); i++) {
            dtmErrores.addRow(new Object[]{tokens.getTokenEST().get(i),tokens.getValorEST().get(i)});
        }
        
        // se llena la tabla de palabras
        for (int i = 0; i < tokens.getTokenPR().size(); i++) {
            dtmPalabras.addRow(new Object[]{tokens.getValorPR().get(i),tokens.getTokenPR().get(i)});
        }
        
        // se escribe el codigo en tokens
        jTextArea2.setText(stbTokens.toString());
        
    }//GEN-LAST:event_jButton1ActionPerformed

    // metodo "busquedaTokens" que sirve para detectar tokens.
    private void busquedaTokens(String input) {
        
        // el stringtokenizer sirve para buscar tokens separados por espacios
        final StringTokenizer st = new StringTokenizer(input);
        
        // esta variable almacena el tipo de variable que se esta guardando.
        String tipo = "null";
        
        // este ciclo recorre todos los tokens
        while (st.hasMoreTokens()) {
            
            // palabra contiene el token a analizar y matched indica si el token existe o no
            String palabra = st.nextToken();
            boolean matched = false;
            
            // se recorren los tipos de token para saber si es un token previamente declarado
            for (Tipo tokenTipo : Tipo.values()) {
                
                // se utilizan las expresiones regulares encontradas en la clase Tipo
                Pattern patron = Pattern.compile(tokenTipo.patron);
                Matcher matcher = patron.matcher(palabra);
                
                // si se concuerda con alguna expresion regular, se verifica con cual y se registra
                if (matcher.find()) {
                    if (tokenTipo.toString().equalsIgnoreCase("PR")) {
                        tokens.setPR(palabra);
                        // matched es true por que el token es correcto
                        matched = true;
                        if (!palabra.equalsIgnoreCase("do") && !palabra.equalsIgnoreCase("while")) {
                            tipo = palabra;
                        }
                        break;
                    }
                    if (tokenTipo.toString().equalsIgnoreCase("IDE")) {
                        tokens.setIDE(palabra, tipo);
                        // matched es true por que el token es correcto
                        matched = true;
                        tipo = "null";
                        break;
                    }
                    if (tokenTipo.toString().equalsIgnoreCase("OA")) {
                        tokens.setOA(palabra);
                        // matched es true por que el token es correcto
                        matched = true;
                        break;
                    }
                    if (tokenTipo.toString().equalsIgnoreCase("OR")) {
                        tokens.setOR(palabra);
                        // matched es true por que el token es correcto
                        matched = true;
                        break;
                    }
                    if (tokenTipo.toString().equalsIgnoreCase("OB")) {
                        tokens.setOB(palabra);
                        // matched es true por que el token es correcto
                        matched = true;
                        break;
                    }
                    if (tokenTipo.toString().equalsIgnoreCase("CE")) {
                        tokens.setCE(palabra);
                        // matched es true por que el token es correcto
                        matched = true;
                        break;
                    }
                    if (tokenTipo.toString().equalsIgnoreCase("CF")) {
                        tokens.setCF(palabra);
                        // matched es true por que el token es correcto
                        matched = true;
                        break;
                    }
                    if (tokenTipo.toString().equalsIgnoreCase("OAS")) {
                        tokens.setOAS();
                        // matched es true por que el token es correcto
                        matched = true;
                        break;
                    }
                    if (tokenTipo.toString().equalsIgnoreCase("SAL1")) {
                        tokens.setSAL1();
                        // matched es true por que el token es correcto
                        matched = true;
                        break;
                    }
                    if (tokenTipo.toString().equalsIgnoreCase("SAL2")) {
                        tokens.setSAL2();
                        // matched es true por que el token es correcto
                        matched = true;
                        break;
                    }
                    if (tokenTipo.toString().equalsIgnoreCase("EXT1")) {
                        tokens.setEXT1();
                        // matched es true por que el token es correcto
                        matched = true;
                        break;
                    }
                    if (tokenTipo.toString().equalsIgnoreCase("EXT2")) {
                        tokens.setEXT2();
                        // matched es true por que el token es correcto
                        matched = true;
                        break;
                    }
                    if (tokenTipo.toString().equalsIgnoreCase("DEL")) {
                        tokens.setDEL();
                        // matched es true por que el token es correcto
                        matched = true;
                        break;
                    }
                    
                }
            }
            
            // pero si no existe el token, se considera un error de identificador mal definido
            if (!matched) {
                String valor = "El identificador " +palabra+ " está mal definido.";
                tokens.setELX(valor);
            }

        }

    }
    
    // metodo del dibujo de tablas
    public void tablas() {
        // se añaden y se asignan las columnas de cada tabla
        
        dtmPalabras.addColumn("Lexema");
        dtmPalabras.addColumn("Tokens");
        dtmSimbolos.addColumn("Tipo");
        dtmSimbolos.addColumn("Lexema");
        dtmSimbolos.addColumn("Tokens");
        dtmSimbolos.addColumn("Valor");
        dtmOperadores.addColumn("Lexema");
        dtmOperadores.addColumn("Tokens");
        dtmConstantes.addColumn("Lexema");
        dtmConstantes.addColumn("Tokens");
        dtmErrores.addColumn("Clave");
        dtmErrores.addColumn("Descripción");

        jTable1.setModel(dtmSimbolos);
        jTable2.setModel(dtmOperadores);
        jTable3.setModel(dtmConstantes);
        jTable4.setModel(dtmErrores);
        jTable5.setModel(dtmPalabras);

    }
    
    // metodo auxiliar para la eliminacion de elementos de un arreglo
    private  static String[] delDeArr (String[] arrayString, int i) {
        
        // se inicializa un nuevo arreglo con un tamaño menor al existente
        String[] nuevoArray = new String[arrayString.length - 1];
        
        if (i > 0){
            System.arraycopy(arrayString, 0, nuevoArray, 0, i);
        }
        
        if (nuevoArray.length > i){
            System.arraycopy(arrayString, i + 1, nuevoArray, i, nuevoArray.length - i);
        }
        
        return nuevoArray;
    }
    
    // metodo auxiliar para contruir un String a partir de un arreglo
    private static String arregloACodigo (String[] arreglo) {
        StringBuilder stbCodigo = new StringBuilder();
        
        for (int i = 0; i < arreglo.length; i++) {
            stbCodigo.append(arreglo[i]);
            if (i + 1 < arreglo.length) {
                stbCodigo.append(" ");
            }
        }
        
        return stbCodigo.toString();
    }
    
    // metodo para la impresión del texto
    private void imprimirTexto(String titulo, String texto) {
        JOptionPane.showMessageDialog(null, texto, titulo, JOptionPane.INFORMATION_MESSAGE);
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(AritmeticasTokens.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(AritmeticasTokens.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(AritmeticasTokens.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(AritmeticasTokens.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new AritmeticasTokens().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JScrollPane jScrollPane5;
    private javax.swing.JScrollPane jScrollPane6;
    private javax.swing.JScrollPane jScrollPane7;
    private javax.swing.JTable jTable1;
    private javax.swing.JTable jTable2;
    private javax.swing.JTable jTable3;
    private javax.swing.JTable jTable4;
    private javax.swing.JTable jTable5;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JTextArea jTextArea2;
    // End of variables declaration//GEN-END:variables
}
